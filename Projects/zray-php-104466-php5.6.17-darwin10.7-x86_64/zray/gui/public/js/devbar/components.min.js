/*
 * jQuery Highlight plugin
 *
 * Based on highlight v3 by Johann Burkard
 * http://johannburkard.de/blog/programming/javascript/highlight-javascript-text-higlighting-jquery-plugin.html
 *
 * Code a little bit refactored and cleaned (in my humble opinion).
 * Most important changes:
 *  - has an option to highlight only entire words (wordsOnly - false by default),
 *  - has an option to be case sensitive (caseSensitive - false by default)
 *  - highlight element tag and class names can be specified in options
 *
 * Usage:
 *   // wrap every occurrance of text 'lorem' in content
 *   // with <span class='highlight'> (default options)
 *   $('#content').highlight('lorem');
 *
 *   // search for and highlight more terms at once
 *   // so you can save some time on traversing DOM
 *   $('#content').highlight(['lorem', 'ipsum']);
 *   $('#content').highlight('lorem ipsum');
 *
 *   // search only for entire word 'lorem'
 *   $('#content').highlight('lorem', { wordsOnly: true });
 *
 *   // don't ignore case during search of term 'lorem'
 *   $('#content').highlight('lorem', { caseSensitive: true });
 *
 *   // wrap every occurrance of term 'ipsum' in content
 *   // with <em class='important'>
 *   $('#content').highlight('ipsum', { element: 'em', className: 'important' });
 *
 *   // remove default highlight
 *   $('#content').unhighlight();
 *
 *   // remove custom highlight
 *   $('#content').unhighlight({ element: 'em', className: 'important' });
 *
 *
 * Copyright (c) 2009 Bartek Szopka
 *
 * Licensed under MIT license.
 *
 */

(function(jQuery){
	jQuery.extend({
		highlight: function (node, re, nodeName, className) {
			if (node.nodeType === 3) {
				var match = node.data.match(re);
				if (match) {
					var highlight = document.createElement(nodeName || 'span');
					highlight.className = className || 'highlight';
					var wordNode = node.splitText(match.index);
					wordNode.splitText(match[0].length);
					var wordClone = wordNode.cloneNode(true);
					highlight.appendChild(wordClone);
					wordNode.parentNode.replaceChild(highlight, wordNode);
					return 1; //skip added node in parent
				}
			} else if ((node.nodeType === 1 && node.childNodes) && // only element nodes that have children
					!/(script|style)/i.test(node.tagName) && // ignore script and style nodes
					!(node.tagName === nodeName.toUpperCase() && node.className === className)) { // skip if already highlighted
				for (var i = 0; i < node.childNodes.length; i++) {
					i += jQuery.highlight(node.childNodes[i], re, nodeName, className);
				}
			}
			return 0;
		}
	});

	jQuery.fn.unhighlight = function (options) {
		var settings = { className: 'highlight', element: 'span' };
		jQuery.extend(settings, options);

		return this.find(settings.element + "." + settings.className).each(function () {
			var parent = this.parentNode;
			parent.replaceChild(this.firstChild, this);
			parent.normalize();
		}).end();
	};

	jQuery.fn.highlight = function (words, options) {
		var settings = { className: 'highlight', element: 'span', caseSensitive: false, wordsOnly: false };
		jQuery.extend(settings, options);
		
		if (words.constructor === String) {
			words = [words];
		}
		words = jQuery.grep(words, function(word, i){
		  return word != '';
		});
		words = jQuery.map(words, function(word, i) {
		  return word.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
		});
		if (words.length == 0) { return this; };

		var flag = settings.caseSensitive ? "" : "i";
		var pattern = "(" + words.join("|") + ")";
		if (settings.wordsOnly) {
			pattern = "\\b" + pattern + "\\b";
		}
		var re = new RegExp(pattern, flag);
		
		return this.each(function () {
			jQuery.highlight(this, re, settings.element, settings.className);
		});
	};
})(this.jQuery);


// CSS attribute escape extension adapted for jQuery
(function(jQuery){
	jQuery.extend({

/*
		Copyright Mathias Bynens <http://mathiasbynens.be/>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Licensed under MIT license.

*/
	
		// http://mathiasbynens.be/notes/css-escapes
		cssEscape: function (string, escapeNonASCII) {
			// Based on `ucs2decode` from http://mths.be/punycode
			if (typeof string != 'string') {
				return '';
			}
			var firstChar = string.charAt(0),
			    output = '',
			    counter = 0,
			    length = string.length,
			    value,
			    character,
			    charCode,
			    surrogatePairCount = 0,
			    extraCharCode; // low surrogate
		
			while (counter < length) {
				character = string.charAt(counter++);
				charCode = character.charCodeAt();
				// if it's a non-ASCII character and those need to be escaped
				if (escapeNonASCII && (charCode < 32 || charCode > 126)) {
					if ((charCode & 0xF800) == 0xD800) {
						surrogatePairCount++;
						extraCharCode = string.charCodeAt(counter++);
						if ((charCode & 0xFC00) != 0xD800 || (extraCharCode & 0xFC00) != 0xDC00) {
							throw Error('UCS-2(decode): illegal sequence');
						}
						charCode = ((charCode & 0x3FF) << 10) + (extraCharCode & 0x3FF) + 0x10000;
					}
					value = '\\' + charCode.toString(16).toUpperCase() + ' ';
				} else {
					// \r is already tokenized away at this point
					// `:` can be escaped as `\:`, but that fails in IE < 8
					if (/[\t\n\v\f:]/.test(character)) {
						value = '\\' + charCode.toString(16).toUpperCase() + ' ';
					} else if (/[ !"#$%&'()*+,./;<=>?@\[\\\]^`{|}~]/.test(character)) {
						value = '\\' + character;
					} else {
						value = character;
					}
				}
				output += value;
			}
		
			if (/^_/.test(output)) { // Prevent IE6 from ignoring the rule altogether
				output = '\\_' + output.slice(1);
			}
			if (/^-[-\d]/.test(output)) {
				output = '\\-' + output.slice(1);
			}
			if (/\d/.test(firstChar)) {
				output = '\\3' + firstChar + ' ' + output.slice(1);
			}
		
			return {
				'surrogatePairCount': surrogatePairCount,
				'output': output
			};
		}
	});
})(this.jQuery);

;(function($){

	/////////////////////////// sticky header ////////////////////////////////////////////////
	$.fn.zdbStickyHeader = function() {
		var setStickyHeader = function($tbl) {
			var _id = $tbl.data('_id');
			var renderedBefore = (!!_id);
			if (!_id) {
				if ($tbl.siblings('[id^="zdb_cloned_"]').length > 0) {
					_id = $tbl.siblings('[id^="zdb_cloned_"]').attr('id').split('_').pop();
				} else {
					$tbl.data('_id', (_id = parseInt(Math.random() * 100000)));
				}
			}

			var $container = $tbl.parent().css('position', 'relative');
			var $tbl2 = $('#zdb_cloned_'+_id).length ? $('#zdb_cloned_'+_id) : 
				$tbl.clone().attr('id', 'zdb_cloned_' + _id).css({background: '#fff', position: 'absolute', zIndex: 100, top: 0, right: 0, left: 0, opacity: 1});
//				$tbl.clone().attr('id', 'zdb_cloned_' + _id).css({background: '#fff', position: 'absolute', zIndex: 100, top: 0, opacity: 1});
			if (!renderedBefore) {
				$tbl.find('thead').css({visibility: 'hidden'});
				$tbl2.find('tbody').remove();
				$tbl2.insertBefore($tbl);

				// update the position on scrolling
				$container.on('scroll', function() {
					var scrollTop = $(this).scrollTop();
					if (scrollTop > 0) {
						if (!$tbl2.hasClass('shadow-bottom')) {
							$tbl2.addClass('shadow-bottom')
						}
					} else {
						$tbl2.removeClass('shadow-bottom')						
					}
					$tbl2.css('top', scrollTop + 'px');
				});
			}
		}

		this.each(function() {
			var $tbl = $(this);
			if ($tbl.get(0).tagName != 'TABLE' || $tbl.is('[id^="zdb_cloned_"]')) return;
			
			setStickyHeader($tbl);
			$(window).on('resize', function() {
				setStickyHeader($tbl);
			});
		});
	};
	
	//////////////////////////////////////////////////////////////////////////////////////////

	// console.error wrapper for internal errors
	var zdbSetError = function() {
		return window.console ? console.error.apply(console, arguments) : false;
	}

	$.devbarStorage = function() {
		this.data = [];
		this.finalData = [];
		this.originalData = null;
		this.filters = {};
		this.columnFilters = {};
		this.countAsHidden = {};
		this.hiddenCount = 0;
		this.sorters = {};
		this.searches = {};
		this.searchTerm = '';
		this.isKeyValueTree = false; // Storage for tree structure - affects search and sort
		this.isRequestInfoTree = false; // Storage for request info tree structure
		this.isTree = false; // Storage for general tree structure
		this.searchCaseSensitive = false;
		this.searchColumns = [];
		this.page = 1;
		this.limit = 40;
		this.sortColumn = null;
		this.sortDirection = 'asc';
		this.filterValues = null;
		this.onChangeCallbacks = [];
		this.dataChanged = false;
		this.cacheSearchData = null;
		this.firstBy = (function(){function e(f){f.thenBy=t;return f}function t(y,x){x=this;return e(function(a,b){return x(a,b)||y(a,b)})}return e})();
		this.timer = null;
		this.skipKeysInTreeObject = ['leaf', 'level', 'node', 'parent']; // skip these keys in a record when searching for a term (only for trees)
	}
	
	$.devbarStorage.prototype = {
		addData: function(data, fireOnChange) {
			if (typeof data == 'object') {
				this.data = this.data.concat(data);
				this.finalData = this.finalData.concat(data);
				this.originalData = null;
			} else {
				this.data.push(data);
				this.finalData.push(data);
				this.originalData = null;
			}
			this.cacheSearchData = null;
			
			if (typeof fireOnChange == 'undefined' || fireOnChange === true) {
				this.fireOnChange('addData');
			} else {
				this.dataChanged = true;
			}
			return this;
		},
		setData: function(data) {
			this.reset();
			this.addData(data, false);
						
			this.fireOnChange('setData');
			return this;
		},
		// remove, and return the removed data
		// query is object with criteria. e.g. query {name:'John Snow'} will remove all corresponding items
		detachData: function(query) {
			var that = this;
			this.cacheSearchData = null;
			
			// remove all if no query supplied
			if (!query) {
				var data = this.data;
				this.data = [];
				this.finalData = [];
				return data;
			}

			var retData = [];

			// delete from `data`
			var removeIndexes = [];
			this.data.forEach(function(elem, i) {
				for (var propertyName in query) {
					if (elem[propertyName] == query[propertyName]) {
						retData.push(elem);
						removeIndexes.push(i);
					}
				}
			});
			removeIndexes.sort(function(a,b){ return a==b?0:(a>b?-1:1);}).forEach(function(removeIndex) {
				that.data.splice(removeIndex, 1);
			});

			// delete from `finalData`
			removeIndexes = [];
			this.finalData.forEach(function(elem, i) {
				for (var propertyName in query) {
					if (elem[propertyName] == query[propertyName]) {
						removeIndexes.push(i);
					}
				}
			});
			removeIndexes.sort(function(a,b){ return a==b?0:(a>b?-1:1);}).forEach(function(removeIndex) {
				that.finalData.splice(removeIndex, 1);
			});
			this.originalData = null;
			
			this.fireOnChange('detachData');
			return retData;
		},
		onChange: function(callback) {			
			this.onChangeCallbacks.push(callback);
			return this;
		},
		fireOnChange: function(referer) {
			var that = this;

			// use `timer` to avoid multiple calls of this function 
			// (effective in calls like storage.sort(XX).filter(YY).search(ZZ))
			// on page load, it reduces the number of execution by two
			if (this.timer) clearTimeout(this.timer);
			this.timer = setTimeout(function() {

				that.finalData = that.data;
				that.originalData = null;
				that.hiddenCount = 0;
				if (that.searchTerm != '') {
					that._search();
				}
				
				if (that.filterValues != null) {
					that._filter();
				}
				
				if (that.sortColumn != null) {
					that._sort();
				}

				$.each(that.onChangeCallbacks, function(key, callback) {
					callback(that, referer);
				});
				
				$(window).trigger('resize');
				zendDevBar.postMessage('resize', zendDevBar.getHeight());

			}, 3);

			return this;
		},
		setSorter: function(column, callback) {
			this.sorters[column] = callback;
			return this;
		},
		setFilter: function(column, callback) {
			this.filters[column] = callback;
			return this;
		},
		setIsKeyValueTree: function() {
			this.isKeyValueTree = true;
			this.isRequestInfoTree = false;
			this.isTree = false;
		},
		setIsRequestInfoTree: function() {
			this.isKeyValueTree = false;
			this.isRequestInfoTree = true;
			this.isTree = false;
		},
		setIsTree: function() {
			this.isKeyValueTree = false;
			this.isRequestInfoTree = false;
			this.isTree = true;
		},
		setSearch: function(column, callback) {
			this.searches[column] = callback;
			return this;
		},
		setSearchColumns: function(columns) {
			this.searchColumns = columns;
			return this;
		},
		setPage: function(page) {
			this.page = page;
			this.fireOnChange('setPage');
			return this;
		},
		getPage: function() {
			return this.page;
		},
		getFilteredTotalCount: function() {
			return this.finalData.length;
		},
		resetSearch: function() {
			this.searchTerm = '';
			this.searchCaseSensitive = false;
			
			this.finalData = this.data;
			this.originalData = null;
			
			this.fireOnChange('resetSearch');
			return this;
		},
		search: function(term, caseSensitive) {
			if (typeof caseSensitive == 'undefined') {
				caseSensitive = false;
			}
			
			this.searchTerm = term;
			this.searchCaseSensitive = caseSensitive;
			
			this.fireOnChange('search');
		},
		_search: function() {
			// for tree search use different method
			if (this.isKeyValueTree || this.isRequestInfoTree || this.isTree) {
				return this._searchTree();
			}
			
			var term = this.searchTerm;
			var caseSensitive = this.searchCaseSensitive;		
						
			var that = this;
			
			var cacheSearchData = this.cacheSearchData;
			if (cacheSearchData == null) {
				
				// clone the data
				cacheSearchData = $.map(that.data, function (obj) {
                    return $.extend(true, {}, obj);
                });
				
				$.each(cacheSearchData, function(key, row) {
					// loop for searchable columns
					$.each(row, function(column, value) {
						if (that.searchColumns.length > 0 && that.searchColumns.indexOf(column) == -1) { 
							return;
						}
						
						var haystack = value;
						if (typeof that.searches[column] != 'undefined') {
							haystack = that.searches[column](haystack, row);
							if (typeof haystack == 'object' || that._isHTML(haystack)) {
								// if its a expanded description, use the full text
								if (typeof haystack == 'object' && haystack.find('.zdb-expand-wrp').length > 0) {
									haystack = haystack.find('.zdb-expand-wrp').first().attr('title')
								} else {
									var cleanHaystack = $(haystack).text();
									if (haystack != '' && cleanHaystack != '') {
										haystack = cleanHaystack;
									}
								}
							}
						}
						
						row[column] = haystack;
					});
				});
				that.cacheSearchData = cacheSearchData;
			}
			
			var newFinalData = [];
			
			$.each(cacheSearchData, function(key, row) {
				var foundrow = false;
				$.each(row, function(column, value) {
					if (that.searchColumns.length > 0 && that.searchColumns.indexOf(column) == -1) { 
						return;
					}
					
					modifiers = '';
					if (! caseSensitive) {
						modifiers = 'i';
					}
					
					var escapedTerm = term.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
					if (typeof value == 'string' && value.search(new RegExp(escapedTerm, modifiers)) > -1) {
						newFinalData.push(that.data[key]);
						foundrow = true;
						return false;
					}
				});
				
				if ( ! foundrow) {
					that.hiddenCount ++;
				}
			});
			
			this.finalData = newFinalData;
			this.originalData = null;
			return this;
		},
		// add keys to skip in a record when searching in a tree
		skipKeys: function(keys) {
			var that = this;
			if (!(keys instanceof Array)) {
				keys = [keys];
			}
			keys.forEach(function(key) {
				if (that.skipKeysInTreeObject.indexOf(key) == -1) {
					that.skipKeysInTreeObject.push(key);
				}
			})
		},
		_searchTree: (function() {
			var that;
			var caseSensitive = false;
			var isTree = false;
			var expandableKey = null; // for tree (zrayTree)
			var searchTerm = false;
			var skipKeys = null; // for trees
			
			// check if the string matches the search term
			var isMatching = function(theString) {
				var modifiers = caseSensitive ? '' : 'i';
				var escapedTerm = searchTerm.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
				return (typeof theString == 'string' && theString.search(new RegExp(escapedTerm, modifiers)) > -1);
			};
			
			// check if one of the items in the object, matches the search term. (used for generalTree)
			var objectMatch = function(record) {
				var match = false;
				if (!(record instanceof Object)) {
					record = [record];
				}
				$.each(record, function(col, colValue) {
					if (skipKeys.indexOf(col) >= 0) return true; // continue
					if (that.isScalar(colValue) && isMatching(colValue.toString())) {
						match = true;
						return false; // break;
					}
				});
				
				return match;
			}
			
			// the tree search function
			var getMatchingElements = function(records) {
				// clone records
				records = that.cloneObject(records);
				
				var matchingRecords = records instanceof Array ? [] : {};
				$.each(records, function(recKey, record) {
					var recordMatch = false;
					var matchingChildrenRecords = [];
					
					if (isTree && expandableKey && (that.isScalar(record[expandableKey]) || !record[expandableKey] || !record[expandableKey].length)) {
						// this object has no children - check if it has to be inside
						if (objectMatch(record)) {
							matchingRecords.push(record);
						}
					} else if (isMatching(recKey.toString()) || (that.isScalar(record) && isMatching(record.toString()))) {
						// check the key and the value (if its scalar)
						
						if (records instanceof Array) {
							matchingRecords.push(record);
						} else {
							matchingRecords[recKey] = record;
						}
					} else if (record instanceof Object) {
						if (isTree) {
							if (expandableKey && record[expandableKey] instanceof Array && record[expandableKey].length > 0) {
								record[expandableKey] = matchingChildrenRecords = getMatchingElements(record[expandableKey]);
							}
						} else {
							matchingChildrenRecords = getMatchingElements(record);
						}
						
						// add the current record if it's matching
						if (Object.keys(matchingChildrenRecords).length > 0) {
							if (isTree) {
								if (record[expandableKey].length > 0 || objectMatch(record)) {
									matchingRecords.push(record);
								}
							} else if (records instanceof Array) {
								matchingRecords.push(matchingChildrenRecords);
							} else {
								matchingRecords[recKey] = matchingChildrenRecords;
							}
						}
					}
				});
				
				// add __row_index if it was in the original object
				if (matchingRecords instanceof Object && Object.keys(matchingRecords).length > 0 && records instanceof Object && records['__row_index']) {
					matchingRecords['__row_index'] = records['__row_index'];
				}
				
				return matchingRecords;
			};
			
			// same as `getMatchingElements` but for request info tree - its structure is a little different
			// (the children elements are not a part of the parent object, but separate rows in which the parent
			// is a string (as usually it's managed in RDBMS))
			var getMatchingElementsInRequestInfoTree = function(records, parent) {
				parent = parent || '';
				var matchingElements = [];
				if (!records || !(records instanceof Array)) return matchingElements;
				
				var addAutomatically = false;
				$.each(records, function(_, record) {
					// add records automatically - used when adding a sub-tree of some root element
					// stop adding when reaching element with same parent again
					if (addAutomatically) {
						if (record['parent'] != parent) {
							matchingElements.push(record);
							return true; // continue;
						} else {
							// reached the same parent, i.e. the next (possible) root
							addAutomatically = false;
						}
					} else if (record['parent'] != parent) {
						return true; // continue;
					}
					
					// if key is matching add all its sub tree
					if (isMatching(record['key'])) {
						matchingElements.push(record);
						// mark to add all the records under this element
						addAutomatically = true;
						return true; // continue;
					} else {
						// check the values
						// decode base64-encoded values
						var val = record['value'] && record['leaf'] ? window.atob(record['value']) : record['value'];
						var oldval = record['oldvalue'] && record['leaf'] ? window.atob(record['oldvalue']) : record['oldvalue'];
						var size = record['size'] && record['leaf'] ? record['size'].toString() : record['size'];
						
						if (isMatching(val) || isMatching(oldval) || isMatching(size)) {
							matchingElements.push(record);
						} else if (record['children'] > 0) {
							// add children
							var matchingChildren = getMatchingElementsInRequestInfoTree(records, record['node']);
							if (matchingChildren && matchingChildren.length > 0) {
								matchingElements.push(record);
								matchingElements = matchingElements.concat(matchingChildren);
							}
						}
					}
				});
				
				return matchingElements;
			};
			
			return function() {
				that = this;
				searchTerm = this.searchTerm;
				caseSensitive = this.caseSensitive;
				skipKeys = this.skipKeysInTreeObject
				isTree = this.isTree;
				
				if (searchTerm) {
					if (isTree) {
						expandableKey = this.getExpandableKey(this.data);
					}
					
					// select the method according to the data structure (request info tree has different structure)
					var searchingFn = this.isRequestInfoTree ? getMatchingElementsInRequestInfoTree : getMatchingElements;
					this.finalData = this.cacheSearchData = searchingFn(this.data);
					this.originalData = null;
				}
				
				return this;
			};
		})(),
		_isHTML: function (str) {
		    var a = document.createElement('div');
		    a.innerHTML = str;
		    for (var c = a.childNodes, i = c.length; i--; ) {
		        if (c[i].nodeType == 1) return true; 
		    }
		    return false;
		},
		// get which column is sorted now (and direction)
		getCurrentSort: function() {
			return (this.sortColumn && this.sortDirection) ? {
				propertyName: this.sortColumn, 
				direction: this.sortDirection
			} : false;
		},
		sort: function(column, direction) {
			if (typeof direction == 'undefined') {
				direction = 'asc';
			}
			
			this.sortColumn = column; 
			this.sortDirection = direction;
			
			this.fireOnChange('sort');
		},
		_sort: function() {
			var that = this;
			var column = this.sortColumn;
			var direction = this.sortDirection.toLowerCase();
			
			// apply the sorting always on the original data
			if (this.originalData) {
				this.finalData = this.originalData.slice(); //cloning
			} else if (this.finalData.length > 0) {
				this.originalData = this.finalData.slice(); //cloning
			}
			
			// if the data manager is for tree, skip the sort, it's done on the tree itself
			if (this.isKeyValueTree || this.isRequestInfoTree) {
				return this; 
			} else if (this.isTree) {
				this._sortTree();
			} else {
				// no custom sorter - use the default one
				if (typeof this.sorters[column] == 'undefined') {
					this.finalData = this.finalData.sort(function(a,b) { 
						var val1 = a[column], val2 = b[column];
						
						// check if the value has to be processed
						if (that.hasColumnFilter(column)) {
							val1 = that.applyColumnFilter(column, val1, a);
							val2 = that.applyColumnFilter(column, val2, b);
						}
						
						// get the real and comparable value of val1
						if (a[column] === null) {
							val1 = '';
						}
						
						if (jQuery && val1 instanceof jQuery) {
							val1 = val1.text();
						}
						
						if (val1 instanceof HTMLElement) {
							val1 = val1.textContent
						}
						if (typeof(val1) == 'string') {
							val1 = val1.toLowerCase()
						}
						
						// fallback
						if (val1 instanceof Object) {
							val1 = Object.keys(val1).length;
						}
						
						// get the real and comparable value of val2
						if (b[column] === null) {
							val2 = '';
						} 
						if (jQuery && val2 instanceof jQuery) {
							val2 = val2.text();
						}
						if (val2 instanceof HTMLElement) {
							val2 = val2.textContent
						}
						if (typeof(val2) == 'string') {
							val2 = val2.toLowerCase()
						}
						
						// fallback
						if (val2 instanceof Object) {
							val2 = Object.keys(val2).length;
						}
						
						// convert to number if both are numbers
						if (val1 == parseFloat(val1) && val2 == parseFloat(val2)) {
							val1 = parseFloat(val1);
							val2 = parseFloat(val2);
						}
						
						if (val1 == val2) return 0; 
						return (val1 > val2) ? 1 : -1; 
					});
					
					if (direction != 'asc') {
						this.finalData = this.finalData.reverse();
					} 
				} else { // custom sorter found
					var sorter = this.sorters[column];
					this.finalData = this.sorters[column](this.finalData, direction);
					if (direction != 'asc') {
						this.finalData = this.finalData.reverse();
					}
				}
			}
			
			return this;
		},
		
		// sort the lowest 
		_sortTree: function(data) {
			var that = this;
			var column = this.sortColumn;
			var direction = this.sortDirection.toLowerCase();
			var dataParameterWasSupplied = !!data;
			data = data || this.finalData;
			var expandableKey = this.getExpandableKey(data);
			
			// no custom sorter - use the default one
			if (typeof this.sorters[column] == 'undefined') {
				data = data.sort(function(a,b) {
					var val1;
					if (a[column] === null || a[column] === false || typeof(a[column]) == 'undefined') {
						val1 = '';
					} else {
						val1 = (typeof(a[column]) == 'string') ? a[column].toLowerCase() : a[column];
						if (val1 instanceof Object) {
							
							// apply column filter
							if (that.columnFilters && that.columnFilters[column]) {
								var tempDiv = document.createElement('div');
								val1 = that.applyColumnFilter(column, val1, a);
								if (val1 instanceof jQuery) {
									val1 = val1.text();
								} else {
									tempDiv.innerHTML = val1;
									val1 = tempDiv.textContent;
								}
							} else {
								// just count the elements
								val1 = Object.keys(val1).length;
							}
						}
					}
					
					var val2;
					if (b[column]===null || b[column] === false || typeof(b[column]) == 'undefined') {
						val2 = '';
					} else {
						val2 = (typeof(b[column]) == 'string') ? b[column].toLowerCase() : b[column];
						if (val2 instanceof Object) {
							// apply column filter
							if (that.columnFilters && that.columnFilters[column]) {
								var tempDiv = document.createElement('div');
								val2 = that.applyColumnFilter(column, val2, b);
								if (val2 instanceof jQuery) {
									val2 = val2.text();
								} else {
									tempDiv.innerHTML = val2;
									val2 = tempDiv.textContent;
								}
							} else {
								// just count the elements
								val2 = Object.keys(val2).length;
							}
						}
					}
					
					// convert to number if both are numbers
					if (val1 == parseFloat(val1) && val2 == parseFloat(val2)) {
						val1 = parseFloat(val1);
						val2 = parseFloat(val2);
					}
					
					if (val1 == val2) return 0; 
					return (val1 > val2) ? 1 : -1; 
				});
				
				
			} else { // custom sorter found
				var sorter = this.sorters[column];
				this.finalData = this.sorters[column](this.finalData, direction);
			}
			
			if (direction != 'asc') {
				data = data.reverse();
			}
			
			// fix the children
			if (data.length) {
				data.forEach(function(obj) {
					if (expandableKey && obj[expandableKey] instanceof Array && obj[expandableKey].length > 0) {
						obj[expandableKey] = that._sortTree(obj[expandableKey]);
					}
				});
			}
			
			// if the data parameter was supplied, return the result, otherwise just update the finalData
			if (dataParameterWasSupplied) {
				return data;
			} else {
				this.finalData = data;
			}
			
			return this;
		},
		
		// set transformation function for sorting
		// filterFn - function(columnValue, record) {...}
		setColumnFilter: function(columnName, filterFn) {
			if (typeof(this.columnFilters[columnName]) == 'undefined') {
				this.columnFilters[columnName] = [];
			}
			this.columnFilters[columnName].push(filterFn);
		},
		
		// check if a column has a defined filter(s)
		hasColumnFilter: function(columnName) {
			return (typeof(this.columnFilters[columnName]) != 'undefined');
		}, 
		
		applyColumnFilter: function(columnName, initialValue, record) {
			if (this.columnFilters[columnName]) {
				for (var i=0, len = this.columnFilters[columnName].length; i<len; i++) {
					initialValue = this.columnFilters[columnName][i](initialValue, record);
				}
			}
			
			return initialValue;
		},
		
		// fireOnChange optional
		filter: function(filters, fireOnChange) {
			this.filterValues = filters;
			
			if (typeof fireOnChange == 'undefined' || fireOnChange === true) {
				this.fireOnChange('filter');
			} else {
				this.dataChanged = true;
			}
			return this;
		},
		_filter: function() {
			var filters = this.filterValues;
			
			var that = this;
			var newFinalData = [];

			//////////////////////////////////////	
			// new filter
			$.each(filters, function(i, filter) {
				if (!filter.column || typeof(filter.value) == 'undefined') {
					return;
				}
				
				var filterColumn = filter.column;
				var filterValue = filter.value;

				if (typeof filterValue != 'object') {
					filterValue = [filterValue];
				}

				// filter the data
				that.finalData = that.finalData.filter(function(row) {

					// check that the column does exist
					if (typeof row[filterColumn] == 'undefined') {
						return false;
					}

					var found = false;
					filterValue.every(function(filterVal) {
						// compare values or use custom function
						if ((typeof that.filters[filterColumn] != 'undefined' && that.filters[filterColumn](row[filterColumn], filterVal, row)) ||
							(typeof that.filters[filterColumn] == 'undefined' && row[filterColumn] == filterVal)) { 
							found = true;
							return false;
						} else {
							return true;
						}
					});
					
					if ( ! found &&
					 	((typeof that.countAsHidden[filterColumn] != 'undefined' && that.countAsHidden[filterColumn](row)) ||
					 	 typeof that.countAsHidden[filterColumn] == 'undefined')) {
					 	
						that.hiddenCount ++;
					}
					return found;
				});
				that.originalData = null;
			});
			return this;
		},
		resetFilters: function() {
			this.filters = {};
			this.filterValues = null;
			
			this.fireOnChange('resetFilters');
			return this;
		},
		resetSort: function() {
			this.sorters = {};
			this.sortColumn = null;
			this.sortDirection = 'asc';
			
			return this;
		},
		reset: function() {
			this.data = [];
			this.finalData = [];
			this.cacheSearchData = null;
			
			this.fireOnChange('reset');
			return this;
		},
		setLimit: function(limit) {
			this.limit = limit;
			this.fireOnChange('setLimit');
			return this;
		},
		getLimit: function() {
			return this.limit;
		},
		// @param - query the data by specific property name
		// e.g. getData({'name':'John Snow'})
		getData: function(query) {
			if (!query) {
				return this.data;
			} else {
				var retData = [];
				this.data.forEach(function(elem) {
					for (var propertyName in query) {
						if (elem[propertyName] == query[propertyName]) {
							retData.push(elem);
						}
					}
				});
				return retData;
			}
		},
		getFinalData: function(allFinalDataWithoutPaging) {
			if (this.dataChanged) {
				this.dataChanged = false;
				this.fireOnChange('getFinalData');
			}
			// dont use limit
			if (this.limit == -1 || allFinalDataWithoutPaging) {
				return this.finalData;
			} else {
				return this.finalData.slice((this.page - 1) * this.limit, this.page * this.limit);
			}
		},
		setCountAsHidden: function(column, callable) {
			this.countAsHidden[column] = callable;
		},
		countHiddenRows: function(allFinalDataWithoutPaging) {
			return this.hiddenCount;
		},
		prependSort: function(columns) {
		},
		
		// helping function to clone object recursively
		cloneObject: function(obj) {
			// check if obj is scalar
			if (!(obj instanceof Object)) {
				return obj;
			} else {
				var newObj = obj instanceof Array ? [] : {};
				if (obj instanceof Array) {
					for (var i=0, total=obj.length; i<total; i++) {
						newObj.push(this.cloneObject(obj[i]));
					}
				} else {
					for (var key in obj) {
						newObj[key] = this.cloneObject(obj[key]);
					}
				}
				
				return newObj;
			}
		},
		
		isScalar: function(item) {
			return (item === 0 || (item && !(item instanceof Object)));
		},
		
		// get the key in the record that is expanded. in all the levels it's the same key 
		// (for generalTree)
		getExpandableKey: function(records) {
			var theRec = null;

			// if `records` is one object, take it
			if (records instanceof Object && !(records instanceof Array)) {
				theRec = records;

				// if records is an array - take the first
			} else if (records instanceof Array && records.length > 0 && records[0] instanceof Object) {
				theRec = records[0];
			}

			if (!theRec) return false;
			for (var key in theRec) {
				if (theRec[key] instanceof Array) {
					return key;
				}
			}

			return false;
		}
	};
	
	
	
	
	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// devbarTable widget
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// base class for a table with its DOM manipulations
	$.devbarTable = function(containerDOMObject, dataManager) {
		// table columns information
		this.columns = [];

		// explicitly defined table header
		this.tableHeaderHtml = false;

		// store the data manager locally
		this.dataManager = dataManager;
		
		var that = this;
		dataManager.onChange(function(dataManager) {
			that.update(dataManager);
		});
		
		// keep the pointer to the object in the DOM (to get it from outside)
		containerDOMObject.devbarTableInstance = this;
		
		// texts when no data is displayed (like "no data" and "no data selected")
		this.labelNoData = 'No data to display'; // when there's no data at all
		this.labelNoDataSelected = 'No data selected'; // when there's no data displayed (all is filtered)

		this.ascendingSortClass = 'zdb-sorted-ascending';
		this.descendingSortClass = 'zdb-sorted-descending';
		this.initialSortDirectionClassPrefix = 'zdb-initial-sort-direction-';

		///////// private members ///////////
		
		// the container element (clear it beforehand)
		if (!containerDOMObject) zdbSetError('devbarTable container was not defined');
		this._container = this._empty(containerDOMObject);
		
		// the id of the table
		this._id = 'zdb-table-' + parseInt(Math.random() * 10000);
		
		this.useStickyHeader = true;
	}
	
	$.devbarTable.prototype.setOptions = function(options) {
		if(options.columns) {
			this.setColumns(options.columns)
		}
		
		if (options.tableHeaderHtml) {
			this.setTableHeaderHtml(options.tableHeaderHtml);
		}
		
		if (typeof options.stickyHeader != 'undefined' && (! options.stickyHeader)) {
			this.noStickyHeader();
		}
	}

	$.devbarTable.prototype.getContainer = function() {
		return this._container;
	};

	/**
	 * Set table header labels
	 * 
	 * @param labels - array of objects in this form
	 * 	{
	 * 		// the title of the column on the screen
	 * 		label: 'Person name',
	 * 
	 *		// the property name of the record from the data storage  
	 * 		propertyName: 'name', 
	 * 
	 * 		// optional! width of the column (the value of `width` attribute)
	 * 		width: '40%',
	 * 
	 * 		attributes: {},
	 * 
	 * 		sortable: true,
	 * 
	 * 		defaultSort: 'asc', // or 'desc'
	 * 
	 * 		// optional! in case of custom HTML 
	 * 		getHtml: function(value, record) {
	 * 			return 'Name is: ' + value;
	 * 		}
	 *  }
	 *  
	 */
	$.devbarTable.prototype.setColumns = function(columns) {
		if (!(columns instanceof Array)) { 
			return zdbSetError('setColumns parameter error. Array needed');
		}
		this.columns = columns;
		
		// get all "getHtml" methods from the columns, and set a column filter in the data manager (storage)
		var that = this;
		columns.forEach(function(colData) {
			if (typeof(colData.getHtml) == 'function') {
				that.dataManager.setColumnFilter(colData.propertyName, colData.getHtml);
			}
		});
		
		this._init();
		
		return this;
	}
	
	$.devbarTable.prototype.getColumns = function() {
		return this.columns;
	}

	/**
	 * Explicitly set the HTML of the header ('th' tags)
	 * e.g. "<th colspan='100%'>One title for all cols.</th>"
	 */
	$.devbarTable.prototype.setTableHeaderHtml = function(tableHeaderHtml) {
		this.tableHeaderHtml = tableHeaderHtml;
		return this;
	};

	$.devbarTable.prototype.reset = function() {
		this._render();
	};

	
	$.devbarTable.prototype._highlightSearchTerm = function(dataManager) {
		dataManager = dataManager || this.dataManager;
		
		if (dataManager.searchTerm != '') {
			/// highlight in all rows in the tablebody 
			// - except for the notice row
			// - except the expandable rows (avoid highighting "array[10]" strings)
			$(this._getTableBody()).find('tr:not(.zdb-table-row-notice):not(:has(.zdb-tree-table-cell-expandable))').highlight(dataManager.searchTerm);
		} else {
			$(this._getTableBody()).unhighlight();
		}
	};
	
	// data - optional! The data can be supplied directly, and not via dataManager
	$.devbarTable.prototype.update = function(dataManager, data) {
		data = data || dataManager.getFinalData();
		this._render(data);
		this._highlightSearchTerm(dataManager);
	};

	$.devbarTable.prototype.noStickyHeader = function() {
		return this.useStickyHeader = false;
	};

	$.devbarTable.prototype.setData = function(data) {
		this._render(data);
	};

	////////////////////// privates! ////////////////////
	
	// private! remove all child elements of the `elem`
	$.devbarTable.prototype._empty = function(elem) {
		while (elem && elem.firstChild) elem.removeChild(elem.firstChild);
		return elem;
	};
	
	$.devbarTable.prototype._getTableBodyHtml = function(table) {
		if (!table) {
			table = document.createElement('table');
			table.setAttribute('id', this._id);
			table.setAttribute('class', 'zdb-table');
			this._container.appendChild(table);
		}

		// check thead
		var thead = table.getElementsByTagName('thead')[0];
		if (!thead) {
			thead = document.createElement('thead');
			table.appendChild(thead);
		}

		// check tr
		var thead_tr = thead.getElementsByTagName('tr')[0];
		if (!thead_tr) {
			thead_tr = document.createElement('tr');
			thead.appendChild(thead_tr);		
		}
		
		// build the th's
		var ths = thead_tr.getElementsByTagName('th')[0];
		if (!ths) {
			var newTh;
			if (this.tableHeaderHtml) {
				$(thead_tr).html(this.tableHeaderHtml);
			} else {
				for (var i=0; i<this.columns.length; i++) {
					var colData = this.columns[i];

					newTh = document.createElement('th');
					newTh.innerHTML = colData.label;
					if (colData.width) { 
						newTh.setAttribute('width', colData.width);
					}
					if (colData.tooltip) { 
						newTh.setAttribute('title', colData.tooltip);
					}
					
					if (colData.sortable) {
						newTh.setAttribute('class', 'zdb-sortable');
					}

					if (colData.initialSortDirection && ['asc', 'desc'].indexOf(colData.initialSortDirection) >= 0) {
						var currentClass = newTh.getAttribute('class');
						newTh.setAttribute('class', currentClass + ' zdb-initial-sort-direction-' + colData.initialSortDirection.toLowerCase());
					}
					
					thead_tr.appendChild(newTh);
				}
			}
		}

		// check tbody
		var tbody = table.getElementsByTagName('tbody')[0];
		if (!tbody) {
			tbody = document.createElement('tbody');
			table.appendChild(tbody);
		}
		
		return tbody;
	};
	
	// private! render the table (w/o data) and add to dom
	$.devbarTable.prototype._getTableBody = function() {
		// get the table
		var table = document.getElementById(this._id);
		
		return this._getTableBodyHtml(table);
	};
	

	$.devbarTable.prototype._init = function() {
		this._render([]);
		this._bindEvents();

		// take the stored state or filter by default sort
		if (zendDevBar.cookieParams && 
			zendDevBar.cookieParams.sortStoredState && 
			zendDevBar.cookieParams.sortStoredState[zendDevBar.getStorageName(this.dataManager)]) {
			var propertyName = zendDevBar.cookieParams.sortStoredState[zendDevBar.getStorageName(this.dataManager)]['propertyName'];
			var direction = zendDevBar.cookieParams.sortStoredState[zendDevBar.getStorageName(this.dataManager)]['direction'];
			var columnIndex = zendDevBar.cookieParams.sortStoredState[zendDevBar.getStorageName(this.dataManager)]['columnIndex'];

			// check if sortable indeed
			if (this.columns[columnIndex] && this.columns[columnIndex]['sortable']) {
				// perform the sort
				this.dataManager.sort(propertyName, direction);
			}

		} else {
			var dataManager = this.dataManager,
				that = this;
			this.columns.every(function(col, idx) {
				if (col.defaultSort) {
					// perform the sort
					dataManager.sort(col.propertyName, col.defaultSort);
					return false;
				}
				return true;
			});
		}

		this._markSortedColumn();
	};
	
	// private! create a dom element for the row
	$.devbarTable.prototype._createRow = function(rowdata, rownumber) {
		return document.createElement('tr');
	};
	
	// private! create a dom element for a specific row cell
	$.devbarTable.prototype._createRowCell = function(rowdata, rownumber, column, colnumber) {
		return document.createElement('td');
	};

	// add the triangle icon near the right column header 
	$.devbarTable.prototype._markSortedColumn = function(data) {
		// get current sort column
		var currentSort = this.dataManager.getCurrentSort();
		if (!currentSort) return;

		// get the column index
		var columnIndex = false;
		this.columns.every(function(colData, idx) {
			if (colData.propertyName == currentSort.propertyName && colData.sortable) {
				columnIndex = idx;
				return false;
			}
			return true;
		});

		// unmark old row/direction
		$('th.zdb-sortable', this._container).removeClass(this.ascendingSortClass).removeClass(this.descendingSortClass);

		// mark new row/direction
		var newClass = currentSort.direction == 'asc' ? this.ascendingSortClass : this.descendingSortClass;
		$('th:eq('+columnIndex+')', this._container).addClass(newClass);
	};
	
	// private! render the table and put it into the container
	// noData - means that there's no data at all, even in the background
	$.devbarTable.prototype._render = function(data) {
		var tbody = this._getTableBody();
		
		// clear the table
		this._empty(tbody);
		this._addHiddenRowsNotice(tbody, data);
		tbody.appendChild(this.getHtml(data));
		
		this._markSortedColumn();
	};
	
	$.devbarTable.prototype._addHiddenRowsNotice = function(tbody, data) {
		if (this.dataManager.countHiddenRows()) {
			var hiddenCount = this.dataManager.countHiddenRows();
			
			var plural = hiddenCount > 1 ? 'are' : 'is';
			var pluralRows = hiddenCount > 1 ? 'rows' : 'row';
			
			var noticeTr = this._createNoticeRow(this.dataManager.countHiddenRows() + ' ' + pluralRows + ' ' + plural + ' not displayed');
			$(noticeTr).addClass('zdb-table-row-notice');
			tbody.appendChild(noticeTr);
		}
	};
	
	
	$.devbarTable.prototype.getHtml = function(data) {
		var i, j, totalData, totalCols;
		// build the td's (data rows)
		if (data && data.length > 0) {
			var fragment = document.createDocumentFragment();
			for (i = 0, totalData = data.length; i < totalData; i++) {
				var rowData = data[i];
				var newTr = this._createRow(rowData, i);
				if (i % 2 != 0) {
					$(newTr).addClass('zdb-even-row');
				}
				
				var previousTd = null;
				
				for (j = 0, totalCols = this.columns.length; j < totalCols; j++) {
					var colData = this.columns[j];
					
					
					/// some row fields should only be display in certain circumstances
					if (colData.displayRowField && ! colData.displayRowField(rowData[colData.propertyName], rowData)) {
						// if this column is not to be displayed extend the previous column to cover
						previousTd.colSpan ++;
						continue;
					}
					
					var newTd = this._createRowCell(rowData, i, colData, j);
					var $newTd = $(newTd);
					if (typeof (colData.getHtml) == 'function') {
						var htmlResult = colData.getHtml(rowData[colData.propertyName], rowData);
						$newTd.html(htmlResult);
					} else {
						if (rowData != null && typeof rowData[colData.propertyName] != undefined) {
							var cellText = '';
							if (rowData[colData.propertyName] instanceof Array) {
								cellText = 'Array(' + rowData[colData.propertyName].length + ')';
							} else if (rowData[colData.propertyName] instanceof Object) {
								cellText = 'Object(' + Object.keys(rowData[colData.propertyName]).length + ')';
							} else {
								cellText = rowData[colData.propertyName];
							}
							var escapedCellText = $('<span>').html(cellText).text();
							$newTd.html(cellText).attr('title', escapedCellText);
						}
					}

					if (colData.width) {
						newTd.setAttribute('width', colData.width);
					}
					
					if (colData.attributes) {
						for (var attrName in colData.attributes) {
							if (attrName == 'class') {
								// split and foreach for case when the class attribute has white spaces
								colData.attributes[attrName].split(/\s+/g).forEach(function(className) {
									$newTd.addClass(className);
								});
							} else {
								newTd.setAttribute(attrName, colData.attributes[attrName]);
							}
						}
					}
					previousTd = newTd;
					newTr.appendChild(newTd);
				}
				
				fragment.appendChild(newTr);
			}

			if (this.useStickyHeader) {
				$(this._container).find('table').zdbStickyHeader();
			}
			
			return fragment;
		}
		
		var noDataTr = this._createNoticeRow(this.dataManager.getData().length == 0 ? this.labelNoData : this.labelNoDataSelected);
		$(noDataTr).addClass('zdb-table-row-empty');
		return noDataTr;
	};
	
	$.devbarTable.prototype._createNoticeRow = function(textContent) {
		var newTr = this._createRow({}, 0);
		var newTd = this._createRowCell({}, 0, {}, 0);
		newTd.textContent = textContent;
		newTd.setAttribute('colspan', this.columns.length);
		newTr.appendChild(newTd);
		return newTr;
	};
	
    // bind click event on sortable columns
	$.devbarTable.prototype._bindSort = function() {
		var dataManager = this.dataManager, 
			colsData = this.columns,
			that = this;
		
		if (! $(this._container).hasClass('zdb-sortable-click')) {
			$(this._container).addClass('zdb-sortable-click');
			$(this._container).on('click', 'th.zdb-sortable', function(event) {
				var colsData = that.columns;
				
				var $this = $(this);
				var thIdx = $this.index();
				var colData = colsData[thIdx];
				var newDirection;
	
				var isSorted = $this.hasClass(that.ascendingSortClass) || $this.hasClass(that.descendingSortClass);
				var reverseSorting = $this.hasClass(that.initialSortDirectionClassPrefix + 'desc');
				var currentStateIsAscending = $this.hasClass(that.ascendingSortClass);
				$('th.zdb-sortable', that._container).removeClass(that.ascendingSortClass).removeClass(that.descendingSortClass);
				if ((isSorted && currentStateIsAscending) || (!isSorted && reverseSorting)) {
					newDirection = 'desc';
					$this.addClass(that.descendingSortClass);
				} else {
					newDirection = 'asc';
					$this.addClass(that.ascendingSortClass);
				}
	
				// store the sort state (by storage name)
				zendDevBar.cookieParams.sortStoredState = zendDevBar.cookieParams.sortStoredState || {};
				zendDevBar.cookieParams.sortStoredState[zendDevBar.getStorageName(dataManager)] = {
					propertyName: colData.propertyName, 
					direction: newDirection,
					columnIndex: thIdx
				};
				zendDevBar.updateCookieParams();
	
				// make the sort
				dataManager.sort(colData.propertyName, newDirection);
			});
		}
	}
	
	$.devbarTable.prototype._bindEvents = function() {
		this._bindSort();
	};
	
	$.devbarTable.prototype.exportResults = function(title, summaryTable) {
		var tempTable = document.createElement('table');
		var tempTbody = this._getTableBodyHtml(tempTable);
		var intersectArrays = function(array1, array2) { 
			return array1.filter(function(n) {
			    return array2.indexOf(n) != -1
			});
		};
			
		var activeFilters = '';
		if (typeof summaryTable != 'undefined') {
			var activeValues = summaryTable.getActiveFilterValues();
			var allValues = summaryTable.getAllFilterValues();
			// display only those filters that actually appear on the current filter table
			activeValues = intersectArrays(activeValues, allValues);
			if (activeValues.length > 0 && activeValues.length != allValues.length) {
				activeFilters = 'Active filters: ' + activeValues.join(', ') + '<br/>';
			}
		}
		
		var rows = this.dataManager.getFinalData(true);
		var data = this.getHtml(rows);
		tempTbody.appendChild(data);
		
		$(this._container).find('table').zdbStickyHeader();
		
		var currUrl = '<a href="' + zendDevBar.popup.find('.zdb-popup-title').text() + '" target="_blank">' + zendDevBar.popup.find('.zdb-popup-title').text() + '</a>';
		if (zendDevBar.isAggregated()) {
			currUrl = 'Aggregated requests<br/><a href="' + zendDevBar.getStorage('requests').data[0].url + '" target="_blank">' + zendDevBar.getStorage('requests').data[0].url + '</a>';
		}
		
		var searchTerm = '';
		if (this.dataManager.searchTerm != '') {
			searchTerm = 'Search term: "' + this.dataManager.searchTerm + '"<br/>';
		}
		
		var tempWrapper = $zendDevBar('\
			<div>\
				<img id="powered-by-zend-server" style="float: right;" alt="Powered by Zend Server" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAAkCAYAAAAO7jHjAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkY4Q0REMjA5QkQ4MTExRTNBQUY4RUM0OEMzMDU5QTRGIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkY4Q0REMjBBQkQ4MTExRTNBQUY4RUM0OEMzMDU5QTRGIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RjhDREQyMDdCRDgxMTFFM0FBRjhFQzQ4QzMwNTlBNEYiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RjhDREQyMDhCRDgxMTFFM0FBRjhFQzQ4QzMwNTlBNEYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4PvcFsAAAIpklEQVR42uxbPW8bRxA9C+pNBelFyz8gNJQ+JCBXCWCqkIGkEdnYSBqKaeROVGc1odkkkBpRTQJIhWggqUSAdG/B5x8Qme4D8/wLlB3mjTyZ7O6dTkcyiW+AxYl3e3uzO2/ffNzp1uXlZfDVN98F/wPZNu2pabcSno+VX3/+MchlurKQL0EuOQBz+egBSG7qJY7vTLvE7xXRd8O033GNjo9wnv7eF/2Oca90ge8sv9+p++j8GdzlJZ69hHP8zDXRf8VzzSaP1NxWcf4lxmFZQp/tHB7Tl0XxNxlkbNpD/H4K49yFcQlYT0w7R18GzwnAycbbEAC5wL19AYJtPGMMw48xboC+NMZj3PsSx7u49xh/y3vv4579BACUczvDWCf4zfpuiHnlMmMX/BBg6QMEDKhtGGQP1/bwexu/V9DWYMRz3LeEcycCBAfoM8b5RxYdDgDyVfzNgGB9NvC8x3j+iejnkvuOuR0IhudjHzrmMkMGDAAKlnPBaqsWRjgXxhoDaBJsa8KIfcGyqzHu7UL0DZR7ZH2WlI5ad5u45jYGCHlzrAmmzGXGDLikXDID4kL8DhwAWxPuln9vAJBjAYInKInI5gPiJ6rvnhhvxaG7TVxzCwC8Fbjice5+58eAxzAwx0kXwvXtg7nOBdgeCvd4jP59YdwNxSYHGGMsjD9WTBYIUF8onZbwLI7b9nFtyeLKg4RzY0Y8xxh7OSzmx4B9GEoG+AycxzDQmQDfiXKxkjmY+fri3BOMxUnAvmIxW9zGbvhMgEwmH2cAtQ84fQDMNrdA6X6Qw2J2cgtvQlK/LfifCAP5HBttIvmbkNm74I9RVgUT38+XY74u+GMFILnkzxNk0rnkkr18+v1RMV+FnAHnBb6WORzmUMgBOA/wbZnDTg6DHIDzkkIOgTwL/s/Kl19/W1anwt9++SnKVyYH4E2SEWrRHz9shg7Q1cyhYVrJcZ0A2DNt14BxlK9qDADNopdT3vsPI2GsBzAOjzskZjCtY/qPYgzvFXP/MAWoSh5Xu6x0GEDXovlN+nYFsGiMUzEvn1snkB6ZNvKwZxHrJIE89LGouWfS11wPFQtLnUI8l/SIZN8YXYouFsfcS5bnhK5NxmOa60Olf1nYIyIG3MSCXVfWoQQZz2ccXqAt048M2jSG1QtcS5IMmPuv2MUFZqHPFpgqaZxXw9i0SM+xLl1xvS3mt0vXbIsPQNAYPhC1HWtFaxCZPh0zdstyne4rmusV9K1a5kcGf8HrafreScDEO5g/6XxHAa/tw4fpM7GpZdNMbGqu34OemzaSIQA2LTsxTggAPcEwA7UQIRaioMYmpUrmnooFhEmTBhqjZsaoS4ZSjHd4zfkEWHxmxNsSQDAEG2HXAY4A7DTE3F3gk2tFa/hadGHvQYZbNmPVLcOQEd8o7/JezaMnNjTp3fIASM6ty0DC+YFYxxAbk+UzAGtiU9oUDuZ+Je4ne70V124vAgj3YpinJSY0NPe0BNMcigWlBalrdoJrbgswDjzPrDjOl9UuOjTjBhKEQp+SMEZXLZxmFO7bBYuza5R6aDeZVk6xVmSMdQsztYwh22DvmvnbFUfS/RVfwgNmqmHNWjHMz9KxrE0EXYeWZ1QxpxLA2HU8w8nCsUkIwLMjDLouLm9JAxow1F2xG7Ge2FHEgjUbg3niPDrfQu2uLUA4FIDfUTvWy7Rw6fzcyAP+6KalGyQvvHnqLoOY800YtogQomnTJ0G2fQRwkcuumv49R79NZmPWCfGbZPyhQ9eeAHrDBUBfCLCQICs8lXGfMmgDx5FjoQKLgSMBlmuLGeeZelZDxX2sT1o3b1vAUOptKb8kkQciyI9LDIYW5r2uzuye5bNtIUHJwn5V8Xc35lEvbqJrXCH6VOz4pmQnMCNf6yQxNvrwhIqI19KCMFITr6oYNet6XB3PnIQQxnhj0+h4ahq5zhpnqQ4pXsOFv1X3pBUGVQ0xnZYrAlEst3yNuuZIZb7Z1AENOGR81IPRdUx2FS+gf5qkIq2E0KFkMVYv63oV3E0I5i7jeWUNftNnhKxQ68B6FhIw6HIWADQ6dBFTcqKhbVgVWb1N1yCBriW1yUY3BqABU1W5s/q/uJZZcDBtMAUQXq2FqJ1xpr8Mg07CFnOdQPjMEfTXZrg+HWyahgQgYtKCyJpd4BpMU7lFTxnDFffZAnOdXieV0TQmRbGrr06YIRhHknEJdCLR2rEwjqzTzUq60IWSkZKIPzd16cVhn6Np2nPRUsA9VHFf6HGBLK8tLnrWEiqWac1aATIklU44dib3JWKrEMAMfXXEaWwUlanWwd5lS/Khw5to2rou+OpiPlAhIbnKDAHeWGYybYDWznguUp/GHD8yjWLYoTwHnZjFqkhGGrr04kiCSo7kJXsAUl1OxCZhXFlF7Z4CanIFD/jk6zpqr7OcCMIEqc9p2iz7hvLAwcrPhVFnqpcoyRQQp1YVMLX0lDeZbgwIQ7XVjqFisY/96EiFYX59VEVppamLySjZHMpShK0InQEIpT7UXuH989FNs3AUh4eeDwW4Drlli62Qke5gDQ7N3+u+Ai25yYy/punABpwVj1zFaeW2qe4ZuorRYu5Bmk/RFgUzFZQr9rnSXX4dF/xVXB4Io5N7lQF6UZUTJq+hpripKsHfP4zIKus8FWUWGzDKao42D7Iu1uqNGatn8QTLYi2z/DfZngCfK/aTIr8RGKAEpV9p3g4+fCVTCVK8plxQzJRUdlCqkW84uqoeVBb1MhaKKSvTKpOwPqZVUC7JkkFCy9xk4/hvMkcbGyADlYaqIkOVrcbJStYJkrBRFMS84UB/adeSRdctzH3kiX1jXXAnwW7wBtsAVJ2YEQv4hepLO6fnKY10U+yeps+FwsV3Y74HjEscpEHugQHLFlaPkN0OE4wzAaHje8Ao+PCdXeSZc9oNTHZ+D/cbJQRtHeWlkiWBGmKsUVqb/inAAAJE4aVRVsmBAAAAAElFTkSuQmCC" />\
				<h2>Zend Server Z-Ray - ' + title + '</h2>\
				' + currUrl + '<br/>\
				' + activeFilters + '\
				' + searchTerm + '\
				Total rows: ' + rows.length + '<br/>\
			</div>\
		');
		tempWrapper.append(tempTable);

		tempWrapper.find('input[type="checkbox"]').remove();
		
		$.each(tempWrapper.find('.zdb-expand-wrp'), function(key, value) {
			$(value).html($(value).attr('title'));
		});
		
		$.each(tempWrapper.find('.zdb-copy-clipboard'), function(key, value) {
			$(value).html($(value).attr('title'));
		});
		
		// remove Request Environment classes
		$.each(tempWrapper.find('.zdb-tree-table-node'), function(key, value) {
			$(value).css('display', 'table-row');
		});
		$.each(tempWrapper.find('.zdb-tree-table-leaf'), function(key, value) {
			$(value).css('display', 'table-row');
		});

		var styleElement = $zendDevBar('<style></style>');
		styleElement.html('\
				@font-face { font-family: "Open Sans"; font-style: normal; font-weight: 400; src: local("Open Sans"), local("OpenSans"), url(' + zendDevBar.baseUrl + '/fonts/open_sans.woff) format("woff");}\
				body {margin: 0; padding: 20px; text-transform: none; font-family: "Open Sans";}\
				table {width: 100%; clear:both; margin-top: 20px; font-size: 14px; border-collapse: collapse;}\
				table thead {text-align: left; color: #006F9D; border-bottom: 1px solid #808080;}\
				table tbody tr td {padding: 2px;}\
				table tbody tr.zdb-even-row {background: #F3F3F3;}\
		');
		tempWrapper.append(styleElement);
		
		var scriptElement = $zendDevBar('<script type="text/javascript"></script>');
		scriptElement.html('function ping() { document.getElementById("powered-by-zend-server").src ="http://www.zend.com/server/redirect/powered-by-zend-server-logo"; } window.history.pushState("", "' + title + '", "' + zendDevBar.baseUrl + '#export");');
		tempWrapper.append(scriptElement);
		
		tempWrapper.append('<script type="text/javascript" src="http://www.zend.com/products/server/license/ping601"></script>');
		
		var win = window.open(); 
		win.document.write(tempWrapper.html());
		win.document.close();
	};

	
	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// TreeTable widget
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// general tree table (base tree table class)
	$.zrayTreeTable = function(containerDOMObject, dataManager) {

		// tree rendering limits
		this.maxElementsPerLevel = zendDevBar.maxElementsPerLevel;
		this.maxElementsInTree = zendDevBar.maxElementsInTree;
		
		// indicator that bind events was already called
		this.eventsBounded = false;
		
		// `optimized` means that the children are loaded and injected to the DOM on click
		// (rather than preloading all elements on load)
		this.optimized = true;
		
		// By which key expand the tree
		this.expandableArrayKey = '';
		
		// root HTML stransform function
		// (supply a function for the expandable key, 
		// i.e. instead of writing "array(2) ["foo", "bar"]", it will be the output of the function)
		this.transformFn = false;
		
		// once transform function is set and data arrives, notify the data manager about it, for correct sorting
		this.dataManagerWasNotifiedAboutTransformFn = false;
		
		// inheritance
		$.devbarTable.call(this, containerDOMObject, dataManager);
		
		// expand the tree upon search
		var that = this;
		dataManager.onChange(function() {
			if (dataManager.searchTerm) {
				that.expandAll();
				$zendDevBar(containerDOMObject).find('.zdb-tree-table-leaf').css('display', 'table-row');
				$zendDevBar(containerDOMObject).find('.zdb-tree-table-node').addClass('zdb-tree-table-node-expanded').css('display', 'table-row');
			}
		});
		
		// tell the storage the it's a (general) tree structure
		dataManager.setIsTree();
	}
	$.zrayTreeTable.prototype = Object.create($.devbarTable.prototype);
	
	// private! create a dom element for a cell row
	$.zrayTreeTable.prototype._createRowCell = function(rowdata, rownumber, column, colnumber) {
		var cell = $.devbarTable.prototype._createRowCell.call(this, rowdata, rownumber, column, colnumber);
		if (colnumber == 0 && (! rowdata.leaf)) {
			$(cell).addClass('zdb-tree-table-cell-expandable');
		}
		return cell;
	}
	
	// create a dom element for the row (`tr`)
	$.zrayTreeTable.prototype._createRow = function(rowdata, rownumber) {
		var row = $.devbarTable.prototype._createRow.call(this, rowdata, rownumber);
		var jrow = $(row);
		if (rowdata.node) {
			jrow.attr('zdb-tree-parent', rowdata.parent);
			jrow.attr('zdb-tree-path', rowdata.node);
			jrow.attr('zdb-tree-end', rowdata.leaf);
			jrow.addClass(rowdata.leaf ? 'zdb-tree-table-leaf' : 'zdb-tree-table-node');
			if (rowdata.parent != '') {
				jrow.hide();
			}
		}
		return row;
	}
	
	// get `tbody` element
	$.zrayTreeTable.prototype._getTableBody = function() {
		var tbody = $.devbarTable.prototype._getTableBody.call(this);
		if (!$(tbody).hasClass('zdb-tree-table')) {
			$(tbody).addClass('zdb-tree-table');
		}
		
		return tbody;
	}
	
	// used to decorate the expanded column cell 
	// in general tree it's always the first column
	$.zrayTreeTable.prototype.expandedColumn = function(val, rec) {
		var cushion = $zendDevBar('<div>');
		/// either the node has children or this is an object with properties
		if (rec.children > 0) {
			cushion.addClass('zdb-tree-table-cell-path-expandable');
		}
		cushion.addClass('zdb-tree-table-cell-path-display');
		if (rec.parent && rec.parent.length > 1) {
			cushion.css('margin-left', (18 * rec.level) + 'px');
		}
		
		cushion.click(function(event){
			$zendDevBar(event.target).parent('td').click();
			$zendDevBar(window).trigger('resize');
		});
		

		var formattedText = val;
		if (typeof formattedText == 'string' && formattedText.trim().length == 0) {
			formattedText = '[Empty String Key]';
			cushion.addClass('zdb-tree-table-system-data');
		} else if (formattedText > 32) {
			cushion.attr('title', formattedText);
			formattedText = zendDevBar.shorten(formattedText, 32);
		}
		
		return cushion.html(formattedText);
	}
	
	// get the `key` of the object inside one data record
	// (used to identify the `children`. more useful when every record has several keys)
	$.zrayTreeTable.prototype._getArrayKey = function(data) {
		var exitLoop = false, 
			returnValue = false,
			that = this;
		jQuery.each(data, function(rowKey, rowValue) {
			if (!(rowValue instanceof Object)) {
				return false;
			}
			
			jQuery.each(rowValue, function(key, value) {
				if (typeof value == 'object') {
					returnValue = key;
					exitLoop = true;
					return false;
				}
			});
			
			if (exitLoop) return false;
		});

		// store the key in the object, assuming that it's the same key for all levels
		if (returnValue) {
			this.expandableArrayKey = returnValue; 
		}
		
		// update first column data to display expand arrow and paddings
		if (!this.expandableKeyColumnUpdated) {
			var firstCol = this.columns[0];
			
			// change "getHtml" function
			var currentGetHtml = firstCol.getHtml;
			this.columns[0].getHtml = function(val, rec) {
				if (typeof(currentGetHtml) == 'function') {
					val = currentGetHtml(val, rec);
				}
				
				val = that.expandedColumn(val, rec);
				
				return val;
			};
			
			// add/update class property in `attributes`
			if (this.columns[0].attributes instanceof Object) {
				if (this.columns[0].attributes['class']) {
					this.columns[0].attributes['class']+= ' zdb-tree-table-cell-path zdb-ellipsis zdb-monospace';
				} else {
					this.columns[0].attributes['class'] = 'zdb-tree-table-cell-path zdb-ellipsis zdb-monospace';
				}
			} else {
				this.columns[0].attributes = {'class':'zdb-tree-table-cell-path zdb-ellipsis zdb-monospace'};
			}
			
			this.expandableKeyColumnUpdated = true;
		}
		
		return returnValue;
	};
	
	
	// supply a function for the expandable key, 
	// i.e. instead of writing "array(2) ["foo", "bar"]", it will be the output of the function
	$.zrayTreeTable.prototype.setRootHtml = function(transformFn) {
		if (typeof(transformFn) == 'function') {
			this.transformFn = transformFn;
		} else {
			this.transformFn = null;
		}
	}
	
	
	// Return string representing `children` object
	// - if `children` is array, it returns "Array(13) ["first element", "second", ...] 
	// 	(the first 5 elements)
	// - if `children` is object, it returns "Object(2 items) {a: "aa", b: "bb"}"
	//  (also first 5 elements)
	// if there are more than 5 elements, "..." are concatenated
	$.zrayTreeTable.prototype.getChildrenRepresentation = function(children, arrayKey, parentItem) {
		
		// check the transform root object
		if (typeof(this.transformFn) == 'function') {
			var newValue = this.transformFn(children,parentItem);
			if (newValue !== false && newValue !== null) {
				return newValue;
			}
		}
		
		// check if the first element in children is string - take it
		if (children instanceof Array && children.length && typeof(children[0]) == 'string' && children[0].length > 0) {
			return children[0];
		}
		
		var value = '';
		var childrenValues = jQuery.map(children, function(child, childKey) {
			// check array key - for general tree (this is the "expandable key") 
			if (arrayKey) {
				child = child[arrayKey] || '';
			}
			
			var retVal = '';
			
			// check if `children` is and object and not an array
			if (!(children instanceof Array)) {
				retVal = childKey + ': ';
			}
			
			if (child instanceof Array) {
				retVal+= 'Array('+child.length+')';
			} else if (child instanceof Object) {
				retVal+= 'Object(' + Object.keys(child).length + ' items)';
			} else if (child && child.toString && childKey != '__row_index') {
				retVal+= '"' + child.toString() + '"';
			} else {
				retVal = "";
			}
			
			return retVal;
		}).filter(function(child) {
			return child != ''; // filter empty values
		});
		var totalChildren = childrenValues.length;
		childrenValues = childrenValues.slice(0, 5);
		childrenValues = childrenValues.join(', ') + (totalChildren > 5 ? ', ...' : '');
		if (children instanceof Array) {
			value = '<strong style="font-weight:bold">Array(' + totalChildren + ')</strong> <span style="color:#888888">[' + childrenValues + ']</span>';
		} else {
			value = '<strong style="font-weight:bold">Object(' + totalChildren + ' items)</strong> <span style="color:#888888">{' + childrenValues + '}</span>';
		}
		
		return value;
	};	
	
	// function(parentPath[, data[, useExpandableArrayKey]])
	// parentPath looks like "node2:node6:..."
	$.zrayTreeTable.prototype.getChildren = (function() {
		var expandableArrayKey = false;
		var _getChildren = function(parentPath, data) {
			if (!parentPath || !data) {
				return data;
			}
			
			// get the number of the first part of the path ("node3:node2:nodeN:.. --> 3)
			var firstElemSerialNumber = parseInt(parentPath.split(':')[0].replace(/node/g, ''));
			var retValue = false;
			$.each(data, function(key, val) {
				// don't count __row_index
				if (key != '__row_index') {
					firstElemSerialNumber--;
				}
				
				if (firstElemSerialNumber == 0) {
					if (expandableArrayKey) {
						// return the value of the `arrayKey`.
						retValue = val[expandableArrayKey];
						
						// wrap with array if needed
						if (!(retValue instanceof Array)) {
							retValue = [retValue];
						} 
					} else {
						retValue = val;
					}
					return false;
				}
			});
			
			if (parentPath.indexOf(':') >= 0) {
				return _getChildren(parentPath.split(':').slice(1).join(':'), retValue);
			} else {
				return retValue;
			}
		};
		
		return function(parentPath, data, useExpandableArrayKey) {
			data = data || this.dataManager.getFinalData();
			expandableArrayKey = useExpandableArrayKey ? (this.expandableArrayKey || this._getArrayKey(data)) : false;
			return _getChildren(parentPath, data);
		};
	})();
	
	
	// sort the generated list from _createTree method
	// (tbody - list of the generated items from _createTree)
	// filterFn - apply filter on the value before sorting it (e.g. base64-decode (window.atob))
	$.zrayTreeTable.prototype._sortCreatedTree = function(tbody, sortColumn, sortDirection, filterFn) {
		if (!sortColumn) return tbody;
		sortDirection = sortDirection || 'asc';
		var that = this;
		
		// validate input
		sortColumn = sortColumn || this.dataManager.sortColumn;
		sortDirection = sortDirection || this.dataManager.sortDirection;
		
		// split the data into list of arrays
		// each array is an item from the current level with its children
		var itemsList = [];
		var currentItem = null;
		var currentLevel = null;
		$.each(tbody, function(_, item) {
			// get the current level
			if (currentLevel === null) {
				currentLevel = item['level'];
			}
			
			// define current item
			if (item['level'] == currentLevel) {
				currentItem = currentItem === null ? 0 : currentItem + 1;
			}
			
			if (typeof(itemsList[currentItem]) == 'undefined') itemsList[currentItem] = [];
			itemsList[currentItem].push(item);
		});
		
		// sort the list of lists (according to the first element in the list)
		itemsList = itemsList.sort(function(arr_a, arr_b) {
			var corelation;

			// prepare the values
			var val1 = arr_a[0][sortColumn];
			var val2 = arr_b[0][sortColumn];
			
			// check if the values have transformation `getHtml` method
			if (typeof(val1) == 'undefined' || typeof(val2) == 'undefined') {
				var fixedValues = false;
				if (that.columns.length) {
					var tempDiv = document.createElement('div');
					that.columns.forEach(function(colData) {
						if (colData.propertyName == sortColumn && typeof(colData.getHtml) == 'function') {
							fixedValues = true;
							if (typeof(val1) == 'undefined') {
								val1 = colData.getHtml(val1, arr_a[0]);
								if (!(val1 instanceof Object)) val1 = jQuery('<div>').html(val1);
								val1 = val1.text();
							}
							
							if (typeof(val2) == 'undefined') {
								val2 = colData.getHtml(val2, arr_b[0]);
								if (!(val2 instanceof Object)) val2 = jQuery('<div>').html(val2);
								val2 = val2.text();
							}
						}
					});
				}
				
				if (!fixedValues) return 0;
			}
			
			// apply filter only for leaf objects :-/ .. 
			// works only for `requests info` tree, but for now it's enough
			if (arr_a[0].leaf && arr_b[0].leaf && filterFn && typeof(filterFn) == 'function') {
				if (val1) val1 = filterFn(val1);
				if (val2) val2 = filterFn(val2);
			}
			
			// if values are Array[N] vs Array[K], than compare N vs K
			if (typeof(val1) != 'undefined' && val1 != null && val1 != false && val2 != null && val2 != false && val1.indexOf && typeof(val2) != 'undefined' && val2.indexOf && val1.indexOf('Array[') === 0 && val2.indexOf('Array[') === 0) {
				// extract only the numbers (N,K)
				val1 = parseInt(val1.replace(/[^\d]/g, ''));
				val2 = parseInt(val2.replace(/[^\d]/g, ''));
			}
			
			// convert values to strings (if both aren't numbers)
			if (typeof(val1) != 'undefined' && typeof(val2) != 'undefined' && typeof(val1) != 'number' || typeof(val2) != 'number' && val1 != null && val1 != false && val2 != null && val2 != false) {
				if (val1 !== null && val1.toString) val1 = val1.toString().toLowerCase();
				if (val2 !== null && val2.toString) val2 = val2.toString().toLowerCase();
			}

			// remove HTML tags from the values
			var $newDiv = $('<div>');
			val1 = $newDiv.html(val1).text().trim();
			val2 = $newDiv.html(val2).text().trim();
			
			// check if they are numbers
			if (parseFloat(val1) == val1 && parseFloat(val2) == val2) {
				val1 = parseFloat(val1);
				val2 = parseFloat(val2);
			}
			
			corelation = (val1 > val2) ? 1 : (val1 == val2 ? 0 : -1); 
			
			if (sortDirection.toLowerCase() != 'asc') {
				corelation = -1 * corelation;
			}
			
			return corelation;
		});
		
		// sort the children in every list
		// (in every list, 0 is the parent, 1 - N is the children tree
		$.each(itemsList, function(listNum, list) {
			
			// remove the parent from the list
			var parentElement = list.shift();
			
			// sort the children
			if (list.length > 1) {
				list = that._sortCreatedTree(list, sortColumn, sortDirection, filterFn);
			}
			
			// return the parent to the list
			list.unshift(parentElement);
			
			// store the new sorted list back into the main list
			itemsList[listNum] = list;
		});
		
		// combine the arrays back
		var result = [];
		$.each(itemsList, function(_, list) {
			result = result.concat(list);
		});
		
		return result;
	};
	
	// override set columns - make expandable key column expandable
	$.zrayTreeTable.prototype.setColumns = function(columns) {
		var that = this;
		if (columns && columns.length) {
			columns.forEach(function(col) {
				if (typeof(col.getHtml) == 'function') {
					that.dataManager.setColumnFilter(col.propertyName, col.getHtml);
				}
			});
		}
		
		$.devbarTable.prototype.setColumns.call(this, columns);
	}
	
	// prepare data for rendering
    $.zrayTreeTable.prototype._createTree = function(data, tbody, parentKey, level) {
    	if (!(data instanceof Object)) return;
    	tbody = tbody || [];
        var counter = 0;
        var that = this;
        level = level || 0;
        parentKey = parentKey || '';
        
        // the key that contains children
        var arrayKey = this.expandableArrayKey || (this.expandableArrayKey = this._getArrayKey(data));
		
        // notify the data manager
        if (arrayKey && !this.dataManagerWasNotifiedAboutTransformFn && typeof(this.transformFn) == 'function') {
    		this.dataManager.setColumnFilter(arrayKey, function(val, rec) {
				return that.getChildrenRepresentation(rec[arrayKey], arrayKey, rec);
			});
    		this.dataManagerWasNotifiedAboutTransformFn = true;
        }
        
    	jQuery.each(data, function(innerKey, innerItem) {
			
			// if the first element is string, skip it, it's the label of the parent
			if (data instanceof Array && innerKey == 0 && typeof(innerItem) == 'string' && innerItem.length > 0) {
				return;
			}
			
    		counter++;
    		var nodeHash = (parentKey ? parentKey + ':' : '') + 'node' + counter;
    		
    		// check if reached the limit
    		if (level > 0 && counter > that.maxElementsPerLevel) {
        		var elem = {key: 'N/A: Reached limit', value: 'Showing maximum ' + that.maxElementsPerLevel + ' elements per tree level', leaf: true, node: nodeHash, parent: parentKey, children: 0, level: level};
        	    tbody.push(elem);
    			return false;
    		}
    		
    		// add necessary properties 
			jQuery.extend(innerItem, {level: level, node: nodeHash, parent: parentKey, leaf: false});
			
			var is_array = innerItem[arrayKey] instanceof Array;
			var children = 0;
			if (innerItem[arrayKey] instanceof Object) {
				children = Object.keys(innerItem[arrayKey]).length;
			}
			
    		var treeNode = jQuery.extend({}, innerItem, {children: children});
    		
			if (children > 0 || is_array) {
    			treeNode[arrayKey] = that.getChildrenRepresentation(innerItem[arrayKey], arrayKey,innerItem);
    		}
			
			if(children == 0){
    			treeNode['leaf'] = true;
    		}
			
    	    tbody.push(treeNode);
    	    
    	    // create the tree for the children (for non-optimized mode)
    	    if (!that.optimized && is_array && innerItem[arrayKey].length > 0) {
    	    	that._createTree(innerItem[arrayKey], tbody, nodeHash, level+1);
    	    }
    	});

    	return tbody;
    };

    // fix zebra stripes of the table
	$.zrayTreeTable.prototype._zebraStripes = function() {
		var visibleRows = $(this._container).find('tr');
		var counter = 0;
		for (var i = 0; i < visibleRows.length; i ++) {
			if ($(visibleRows[i]).css('display') == 'none') {
				continue;
			}
			
			if (counter % 2 != 0) {
				$(visibleRows[i]).addClass('zdb-even-row');
			} else {
				$(visibleRows[i]).removeClass('zdb-even-row');
			}
			
			counter++;
		}
	}
	
	$.zrayTreeTable.prototype._bindEvents = function() {
		if (this.eventsBounded) {
			return;
		}
		this.eventsBounded = true;
		var that = this;
		$(this._container).click('td.zdb-tree-table-cell-expandable', $.proxy(function(event) {
			var eventTarget = event.target,
				$eventTarget = $(eventTarget), 
				$container = $(this._container),
				$subject = $eventTarget.parent('tr');
			
			if (event.target.tagName != 'TD' || !$eventTarget.hasClass('zdb-tree-table-cell-expandable')) {
				return;
			}
			
			if ($eventTarget.hasClass('zdb-tree-table-cell-expandable')) {
				if ($subject.hasClass('zdb-tree-table-node-expanded')) {
					if (that.optimized) {
						$container.find('tr[zdb-tree-parent^="' + $.cssEscape($subject.attr('zdb-tree-path')).output + '"]').remove();
					} else {
						$container.find('tr[zdb-tree-parent^="' + $.cssEscape($subject.attr('zdb-tree-path')).output + '"]').hide().removeClass('zdb-tree-table-node-expanded');
					}
					$subject.removeClass('zdb-tree-table-node-expanded');
				} else {
					if (that.optimized) {
						// get the children of the node (one level)
						var childrenData = [];
						var nodeTreePath = $subject.attr('zdb-tree-path'),
							level = nodeTreePath.split(':').length,
							nodeChildren = this.getChildren($subject.attr('zdb-tree-path'), false, 'use expandable array key = true');
						
						// create `childrenData` - renderable array
						childrenData = that._createTree(nodeChildren, childrenData, nodeTreePath, level);
						
						// add the children after the node
						$(this.getHtml(childrenData)).insertAfter($subject);
					}
					
					$container.find('tr[zdb-tree-parent="' + $.cssEscape($subject.attr('zdb-tree-path')).output + '"]').show();
					$subject.addClass('zdb-tree-table-node-expanded');
				}
			} else {
				return false;
			}
			this._zebraStripes();
			this._highlightSearchTerm();
		}, this));
		
		this._bindSort();
	}
    
	$.zrayTreeTable.prototype.update = function(dataManager) {
		dataManager = dataManager || this.dataManager;
		var data = dataManager.getFinalData();
		if (data.length > 0) {
			var treeData = this._createTree(data);
			this._render(treeData);
		} else {
			this._render(data);
		}
		
		if (dataManager.searchTerm != '') {
			/// highlight in all rows in the tablebody except for the notice row that notifies the user about hidden rows
			$(this._getTableBody()).find('tr:not(.zdb-table-row-notice)').highlight(dataManager.searchTerm);
		} else {
			$(this._getTableBody()).unhighlight();
		}
	};

	// "Expand all" re-draws the table with all the levels (unlike the `optimized` mode where levels are created dynamically)
	$.zrayTreeTable.prototype.expandAll = function(dataManager) {
		var optimizedVal = this.optimized;
		this.optimized = false;
		
		this.update();
		
		this.optimized = optimizedVal;
	};
	
	// Remove all the children from DOM for optimized mode
	$.zrayTreeTable.prototype.collapseAll = function(dataManager) {
		if (this.optimized) {
			this.update();
		}
	};
	
    
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// TreeTable widget
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	
	// extend the regular table
	$.devbarTreeTable = function(containerDOMObject, dataManager) { 
		// add keys to skip in a record when searching in a tree
		dataManager.skipKeys(['childDiff', 'children', 'diff', 'oldvalue', 'parent', 'root']);
		
		// inheritance
		$.zrayTreeTable.call(this, containerDOMObject, dataManager);
		
		// tell the data manager the tree structure
		dataManager.setIsRequestInfoTree();
	}
	$.devbarTreeTable.prototype = Object.create($.zrayTreeTable.prototype);
	
	// private! create a dom element for the row
	$.devbarTreeTable.prototype._createRow = function(rowdata, rownumber) {
		var row = $.devbarTable.prototype._createRow.call(this, rowdata, rownumber);
		var jrow = $(row);
		if (rowdata.node) {
			jrow.attr('zdb-tree-parent', rowdata.parent);
			jrow.attr('zdb-tree-path', rowdata.node);
			jrow.attr('zdb-tree-end', rowdata.leaf);
			jrow.addClass(rowdata.leaf ? 'zdb-tree-table-leaf' : 'zdb-tree-table-node');
			if (typeof rowdata.diff != 'undefined' && rowdata.diff != false) {
				jrow.addClass('zdb-tree-table-cell-path-diff-'+rowdata.diff);
			}
			if (typeof rowdata.childDiff != 'undefined' && rowdata.childDiff.length > 0) {
				jrow.attr('zdb-tree-ancestor-of', rowdata.childDiff.join(','));
			}
			if (rowdata.parent != '') {
				jrow.hide();
			}
		}
		return row;
	}
	
	// avoid parent class override
	$.devbarTreeTable.prototype.update = function(dataManager) {
		dataManager = dataManager || this.dataManager;
		
		// sort the data
		var data = dataManager.getFinalData();
		var sortColumn = dataManager.sortColumn; 
		var sortDirection = dataManager.sortDirection;
		var filterFn = sortColumn == 'value' || sortColumn == 'oldvalue' ? window.atob : null;
		data = this._sortCreatedTree(data, sortColumn, sortDirection, filterFn);
		
		$.devbarTable.prototype.update.call(this, dataManager, data);
	};
	
	$.devbarTreeTable.prototype._bindEvents = function() {
		if (this.eventsBounded) {
			return;
		}
		this.eventsBounded = true;
		
		$(this._container).click('td.zdb-tree-table-cell-expandable', $.proxy(function(event) {
			var $eventTarget = $(event.target), 
				$container = $(this._container),
				$subject = $eventTarget.parent('tr');
			if ($eventTarget.hasClass('zdb-tree-table-cell-expandable')) {
				if ($subject.hasClass('zdb-tree-table-node-expanded')) {
					$container.find('tr[zdb-tree-parent^="' + $.cssEscape($subject.attr('zdb-tree-path')).output + '"]').hide();
					$container.find('tr[zdb-tree-parent^="' + $.cssEscape($subject.attr('zdb-tree-path')).output + '"]').removeClass('zdb-tree-table-node-expanded');
					$subject.removeClass('zdb-tree-table-node-expanded');
				} else {
					$container.find('tr[zdb-tree-parent="' + $.cssEscape($subject.attr('zdb-tree-path')).output + '"]').show();
					$subject.addClass('zdb-tree-table-node-expanded');
				}
			} else {
				return false;
			}
			this._zebraStripes();
		}, this));
		
		this._bindSort();
	}
	
	$.devbarTreeTable.prototype._render = function(data) {
		$.devbarTable.prototype._render.call(this, data);
		this._zebraStripes();
	}
	
    //////////////////////
	// Key Value TreeTable widget
	//////////////////////
	
	// extend the regular table
	$.devbarKeyValueTreeTable = function(containerDOMObject, dataManager) {
		
		// inheritance
		$.zrayTreeTable.call(this, containerDOMObject, dataManager);
		
		// tell the data manager that it's a (regular) tree structure
		dataManager.setIsKeyValueTree();
		
		// set initial columns
		this.setColumns();
	};
	$.devbarKeyValueTreeTable.prototype = Object.create($.zrayTreeTable.prototype);
	
	
	// used to decorate the expanded column cell
	$.devbarKeyValueTreeTable.prototype.expandedColumn = function(val, rec) {
		var cushion = $zendDevBar('<div>');
		/// either the node has children or this is an object with properties
		if (rec.children > 0) {
			cushion.addClass('zdb-tree-table-cell-path-expandable');
		}
		cushion.addClass('zdb-tree-table-cell-path-display');
		if (rec.parent && rec.parent.length > 1) {
			cushion.css('margin-left', (18 * rec.level) + 'px');
		}
		
		cushion.click(function(event){
			$zendDevBar(event.target).parent('td').click();
		});
		

		var formattedText = val;
		if (typeof formattedText == 'string' && formattedText.trim().length == 0) {
			formattedText = '[Empty String Key]';
			cushion.addClass('zdb-tree-table-system-data');
		} else if (formattedText > 32) {
			cushion.attr('title', formattedText);
			formattedText = zendDevBar.shorten(formattedText, 32);
		}
		
		return cushion.text(formattedText);
	}
	
	// define default columns for the key-value tree
	$.devbarKeyValueTreeTable.prototype.setColumns = function(columns) {
		var that = this;
		this.columns = [{
			label: 'Key',
			propertyName: 'key',
			width: '25%',
			attributes: {'class': 'zdb-tree-table-cell-path zdb-ellipsis zdb-monospace'},
			getHtml: that.expandedColumn,
			sortable: true
		}, {
			label: 'Value',
			propertyName: 'value',
			width: '75%',
			attributes: {'class': 'zdb-monospace zdb-ellipsis'},
			getHtml: function(val, rec) {
				var expandor = zendDevBar.expendedText(val);
				return expandor;
			},
			sortable: true
		}];
		
		this._init();
		
		return this;
	}
	
	$.devbarKeyValueTreeTable.prototype.getChildren = function(parentPath, data) {
		if (!data) {
			data = this.dataManager.getFinalData();
			if (this.initiallyShifted) {
				data = data[0];
			}
		}
		
		var children = $.zrayTreeTable.prototype.getChildren.call(this, parentPath, data, false); 
		return children;
	}
	
	// parameters order in the parent: 
	// parentKey, item, tbody, arrayKey, level
	$.devbarKeyValueTreeTable.prototype._createTree = function(data, tbody, parentKey, level) {
		if (!(data instanceof Object)) return;
		tbody = tbody || [];
		var counter = 0;
		var that = this;
		level = level || 0;
		
		// for the first time, check if shift is needed (when only one item in the first level)
		if ((typeof(this.initiallyShifted) == 'undefined' || this.initiallyShifted === true) && level == 0 && data && data instanceof Array && data.length == 1) {
			data = data[0];
			if (data instanceof Object) {
				this.initiallyShifted = true;
			} else {
				data = [data];
			}
		} else if (typeof(this.initiallyShifted) == 'undefined') {
			this.initiallyShifted = false;
		}
		
		var parentKeyHash = (typeof parentKey == 'undefined') ? '' : parentKey + ':';
		parentKey = (typeof parentKey == 'undefined') ? '' : parentKey;
		
    	jQuery.each(data, function(key, item) {
    		if (key == '_object_type' || key == '__row_index') return;
    		
    		counter++;
    		var keyName = key;
    		var nodeHash = 'node' + counter;
    		
    		// check if reached the limit
    		if (level > 0 && counter > that.maxElementsPerLevel) {
        		var elem = {key: 'N/A: Reached limit', value: 'Showing maximum ' + that.maxElementsPerLevel + ' elements per tree level', leaf: true, node: nodeHash, parent: parentKey, children: 0, level: level};
        	    tbody.push(elem);    			
    			return false;
    		}
		
    		var numOfChildren = 0;
    		var objectName = null;
    		if (item instanceof Object) {
    			  numOfChildren = Object.keys(item).length;
    			  if (typeof item['_object_type'] != 'undefined') {
    				  objectName = item['_object_type'];
    			  }
    			  if (typeof keyName == 'number' && typeof item['__row_index'] != 'undefined' && ! jQuery.isNumeric(item['__row_index'])) {
    				  keyName = item['__row_index'];
    				  numOfChildren--;
    			  }
    		}
    		
    		var stopRecursive = false;
    		var value = item;
    		if (numOfChildren > 0) {
    			if (objectName == null) {
    				var valueKeys = Object.keys(value);
    				// when there's only one children, that is scalar, display it's value, and don't dive into recursion 
    				if (numOfChildren == 1 && level == 0 && !(value[valueKeys[0]] instanceof Object) && !that.dataManager.searchTerm) {
    					value = value[valueKeys[0]];
    					stopRecursive = true;
    				} else {
    					value = that.getChildrenRepresentation(item);
    				}
    			} else {
    				value = 'Class: ' + objectName + ''; 
    			}
    		}
    		
    		var leaf = (numOfChildren == 0);

    		var nodeHash = parentKeyHash + 'node' + counter
    		var elem = {key: keyName, value: value, leaf: leaf, node: nodeHash, parent: parentKey, children: numOfChildren, level: level};
    	
    	    tbody.push(elem);
    	    
    	    // return only the first level (don't go into recursion) in optimized mode
    	    // (where not all the dom is loaded
    	    if (that.optimized || stopRecursive) {    	    	
    	    	return;
    	    }
    	    
    	    // dive into recursion
    	    if (item instanceof Object) {
    	    	that._createTree(item, tbody, nodeHash, (level+1));
    	    }
    	});
    	
    	// sort the created tree
		// get sort parameters from the data manager (do the sort here)
		var sortColumn = this.dataManager.sortColumn; 
		var sortDirection = this.dataManager.sortDirection;
   		tbody = this._sortCreatedTree(tbody, sortColumn, sortDirection);
   		
    	return tbody;
	}
	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// SUMMARY TABLE 
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// extend the regular table
	$.devbarSummaryTable = function(containerDOMObject, dataManager) {
		// inheritance
		var table = $.devbarTable.call(this, containerDOMObject, dataManager);
		// public
		this.updateCallback = null;
		this.filterColumn = null;
		// private
		this._activeFilters = false;
		this._storageName = zendDevBar.getStorageName(this.dataManager);
	}
	$.devbarSummaryTable.prototype = Object.create($.devbarTable.prototype);


	// update checkboxes according to `activeFilters`
	$.devbarSummaryTable.prototype._updateCheckboxes = function() {
		var that = this, statusOfAll = true;
		var checkboxes = $('tbody input[type="checkbox"][name!="All"]', this._container);

		if (checkboxes.length == 0) {
			statusOfAll = false;
		}

		checkboxes.each(function(i, obj) {
			var $obj = $(obj),
				isChecked = (!that.activeFilters().defined()) || that.activeFilters().get($obj.attr('name'));

			$obj.prop('checked', isChecked);

			if (!isChecked) {
				statusOfAll = false;
			}
		});

		// update "All"
		$('tbody input[type="checkbox"][name="All"]', this._container).prop('checked', statusOfAll)
	}

	// selected filter items storage (cookie)
	$.devbarSummaryTable.prototype.storedState = function() {
		var that = this;
		return {
			// get array of stored filters or false
			get: function() {
				return zendDevBar.cookieParams && 
						zendDevBar.cookieParams.filterStoredState && 
						typeof zendDevBar.cookieParams.filterStoredState[that._storageName] != 'undefined' ?
					zendDevBar.cookieParams.filterStoredState[that._storageName] : false;
			},
			set: function(filterValues) {
				if (!zendDevBar.cookieParams.filterStoredState) {
					zendDevBar.cookieParams.filterStoredState = {};
				}
				if (zendDevBar.cookieParams && zendDevBar.cookieParams.filterStoredState) {
					zendDevBar.cookieParams.filterStoredState[that._storageName] = filterValues;
					zendDevBar.updateCookieParams();
				}
			},
			// completely remove the stored state for the current namespace
			remove: function() {
				if (zendDevBar.cookieParams && 
					zendDevBar.cookieParams.filterStoredState && 
					zendDevBar.cookieParams.filterStoredState[that._storageName]) {
					delete zendDevBar.cookieParams.filterStoredState[that._storageName];
					zendDevBar.updateCookieParams();
				}
			}
		};
	};

	$.devbarSummaryTable.prototype.activeFilters = function() {
		var that = this;
		return {
			// set({a:1,b:2}) OR set('a', 1) OR set(false);
			// set({...}) or set(false) overrides!
			set: function(key, value) {
				if (typeof (value) == 'undefined') {
					value = true;
				}
				
				// if `key` is object or false, just set 
				if (key instanceof Object || key === false) {
					if (key instanceof Array) key = {};
					that._activeFilters = key;
				} else {
					if (that._activeFilters === false) {
						that._activeFilters = {};
					}

					that._activeFilters[key] = value;
				}

				// update storage & dom
				that.storedState().set(that._activeFilters);
				that._updateCheckboxes();
			},
			get: function(key) {
				if (typeof(key) == 'undefined') {
					return that._activeFilters;
				} else {
					return that._activeFilters === false ? false : that._activeFilters[key];
				}
			},
			// get only those keys that their value is true
			getSelected: function() {
				var filters = that._activeFilters === false ? [] : Object.keys(that._activeFilters);
				return filters.filter(function(elem) {return that._activeFilters[elem]; });
			},
			defined: function() {
				return (that._activeFilters !== false);
			},
			remove: function() {
				that._activeFilters = false;

				// update storage & dom
				that.storedState().remove();
				that._updateCheckboxes();
			}
		}
	}

	// set default values of the filter to be marked 
	// (if there is stored state, take it first and avoid the parameter)
	// @param bool override - take the parameter `filters` regardless the stored state
	$.devbarSummaryTable.prototype.setFilterValues = function(filters, avoidStoredState) {

		if (!this.filterColumn) {
			zdbSetError('`setFilterValues` called before `setFilterColumn`. Cannot start filtering');
			return;
		}

		// get the right value
		var newFilterValues = this.storedState().get();
		if (!newFilterValues || avoidStoredState) {
			newFilterValues = filters;
		}

		// update `activeFilters` and checkboxes
		newFilterValues = newFilterValues || false;
		if (newFilterValues instanceof Array) {
			var newObj = {};
			newFilterValues.forEach(function(elem) {
				newObj[elem] = true;
			});
			newFilterValues = newObj;
		}
		this.activeFilters().set(newFilterValues);
		
		// perform the filter
		this.dataManager.filter([{'column': this.filterColumn, 'value': this.activeFilters().getSelected()}]);
	};

	$.devbarSummaryTable.prototype.getActiveFilterValues = function() {
		var filterValues = [];

		// if no active filters - return the checked checkboxes
		if (!this.activeFilters().defined()) {
			$('tbody input[type="checkbox"][name!="All"]', this._container).each(function(i, obj) {
				var $obj = $(obj);
				if ($obj.prop('checked')) {
					filterValues.push($obj.attr('name'));
				}
			});
		} else {
			filterValues = this.activeFilters().getSelected();
		}
		return filterValues;
	};

	$.devbarSummaryTable.prototype.getAllFilterValues = function() {
		var filterValues = [];
		$('tbody input[type="checkbox"][name!="All"]', this._container).each(function(i, obj) {
			filterValues.push($(obj).attr('name'));
		});
		return filterValues;
	};

	$.devbarSummaryTable.prototype.createCheckboxColumn = function(val, rec) {
		var isChecked = (!this.activeFilters().defined()) || this.activeFilters().get(val);
		var isChecked = (!this.activeFilters().defined()) || this.activeFilters().get(val);
		return '<input type="checkbox" name="' + val + '"'+(isChecked?' checked="checked"':'')+'>';
	};
	$.devbarSummaryTable.prototype.setUpdateCallback = function(callback) {
		this.updateCallback = callback;
		return this;
	}
	$.devbarSummaryTable.prototype._init = function() {
		$.devbarTable.prototype._init.call(this);

		// load saved filters state
		var storedStateValues = this.storedState().get();
		this.activeFilters().set(storedStateValues);
		
		// filter the data if there was stored state
		if (storedStateValues !== false) {
			this.dataManager.filter([{'column': this.filterColumn, 'value': this.getActiveFilterValues()}]);
		}
	};
	$.devbarSummaryTable.prototype.getFilterColumn = function() {
		return this.filterColumn;
	};
	$.devbarSummaryTable.prototype.setFilterColumn = function(column) {
		this.filterColumn = column;
		
		var that = this;
		var tableBody = $(this._container);
		tableBody.on('click', 'tbody tr', function(event) {
			var $chkbx = $(':checkbox', this);
			if (event.target.type && event.target.type.toLowerCase() == 'checkbox') {
				$chkbx.prop('checked', !$chkbx.prop('checked'));
			}
			$chkbx.prop('checked', !$chkbx.prop('checked'));
			
			// update active filters (it will update the checkboxes)
			if ($chkbx.attr('name') == 'All') {
				var newActiveFiltersValues = {};
				if ($chkbx.prop('checked')) {
					// set new state (all items as true)
					that.getAllFilterValues().forEach(function(name) {
						newActiveFiltersValues[name] = true;
					});
				} else {
					// set new state (all items as false)
					that.getActiveFilterValues().forEach(function(name) {
						newActiveFiltersValues[name] = false;
					});
				}
				that.activeFilters().set(newActiveFiltersValues);
			} else {
				if ($chkbx.prop('checked')) {
					that.activeFilters().set($chkbx.attr('name'));
				} else {
					// store the current state if no filter was defined before
					if (!that.activeFilters().defined()) {
						// mark all as true
						var newActiveFiltersValues = {};
						that.getActiveFilterValues().forEach(function(name) {
							newActiveFiltersValues[name] = true;
						});

						// mark only the item as false
						newActiveFiltersValues[$chkbx.attr('name')] = false;

						// update local active filters and the checkboxes
						that.activeFilters().set(newActiveFiltersValues);
					} else {
						// update state for the current item
						that.activeFilters().set($chkbx.attr('name'), false);
						// uncheck "all"
						// tableBody.find('input[type="checkbox"][name="All"]').prop('checked', false);
					}

				}

			}
			that.dataManager.filter([{'column': that.filterColumn, 'value': that.getActiveFilterValues()}]);
		});
		
		return this;
	}
	$.devbarSummaryTable.prototype.update = function(dataManager) {
		// get the updated data
		var data = dataManager.getData();
		
		if (this.updateCallback != null) {
			data = this.updateCallback(data);
		}
		
		this._render(data);

		this._updateCheckboxes();
	}
	
	$.devbarSummaryTable.prototype._render = function(data) {
		var tbody = this._getTableBody();
		
		// clear the table
		this._empty(tbody);
		tbody.appendChild(this.getHtml(data));

		this._markSortedColumn();
	}
	
})(jQuery);

;(function($){

	$.zdbPager = function(storage, domElement){
		
		this.page = 1;
		this.rowlimit = 20;
		this.total = 0;
		this.storage = storage;
		this.domElement = domElement;
		this.onChangeGoToFirst = true;
		
		storage.onChange(this.getChangeListener());
		this.connect();
		this.change();
		
		// set default value according to cookie value
		if (typeof zendDevBar != 'undefined' && zendDevBar.getPagerSize() > 0) {
			this.rowlimit = zendDevBar.getPagerSize();
			this.storage.setLimit(zendDevBar.getPagerSize());
			$(this.domElement).find('select').val(zendDevBar.getPagerSize());
		} else {
			this.storage.setLimit(this.rowlimit);
		}
	};
		
	$.zdbPager.prototype = {
		next: function(){
			if ((this.page * this.rowlimit) < this.total) {
				this.page++;
				this.storage.setPage(this.page);
			}
		},
		prev: function() {
			if (this.page > 1) {
				this.page--;
				this.storage.setPage(this.page);
			}
		},
		first: function() {
			if (this.page > 1) {
				this.page = 1;
				this.storage.setPage(this.page);
			}
		},
		last: function() {
			if ((this.page * this.rowlimit) < this.total) {
				this.page = Math.ceil(this.total / this.rowlimit);
				this.storage.setPage(this.page);
			}
		},
		limit: function(event) {
			this.first();
			this.rowlimit = $(event.currentTarget).val();
			this.storage.setLimit(this.rowlimit);
			
			zendDevBar.setPagerSize(this.rowlimit);
		},
		describe: function() {
			var element = $(this.domElement);
			var lastentry = (this.page * this.rowlimit);
			var lastpage = lastentry >= this.total ? true : false;
			
			if (this.total == 0) {
				element.addClass('hidden');
			} else {
				element.removeClass('hidden');
				element.find('span.pagedisplay').text('Showing ' + ((this.page-1) * this.rowlimit + 1) + '-' + (lastpage ? this.total : lastentry) + '/' + this.total);
			}
			
			if (this.page == 1) {
				element.find('.first,.prev').addClass('disabled');
			} else {
				element.find('.first,.prev').removeClass('disabled');
			}
			
			if (lastpage) {
				element.find('.last,.next').addClass('disabled');
			} else {
				element.find('.last,.next').removeClass('disabled');
			}
		},
		change: function(storage,origin) {
			var element = $(this.domElement);
			this.total = this.storage.getFilteredTotalCount();
			
			if (this.total < this.rowlimit && this.page > 1) {
				this.page = 1;
				this.storage.setPage(this.page);
			}
			
			if (origin != 'setPage' && this.onChangeGoToFirst) {
				this.first();
			}
			this.describe();
		},
		connect: function() {
			var element = $(this.domElement);
			element.find('div.next').click($.proxy(this.next, this));
			element.find('div.prev').click($.proxy(this.prev, this));
			element.find('div.first').click($.proxy(this.first, this));
			element.find('div.last').click($.proxy(this.last, this));
			element.find('select.pagelimit').change($.proxy(this.limit, this));
		},
		getChangeListener: function(){
			return $.proxy(this.change,this);
		}
	}
})(jQuery);


;(function($){
	$.zdbSearch = function(storage, domElement, tableDom){
		
		this.term = '';
		this.storage = storage;
		this.domElement = domElement;
		this.timer = null;
		
		if (tableDom) {
			var searchColumns = [];
			$.each(tableDom.getColumns(), function(key, value) {
				searchColumns.push(value.propertyName);
				if (typeof value.getHtml != undefined) {
					storage.setSearch(value.propertyName, value.getHtml);
				}
			});
			
			storage.setSearchColumns(searchColumns);
		}
		
		this.connect();
	};
		
	$.zdbSearch.prototype = {
		describe: function() {
			var element = $(this.domElement);
			var lastentry = (this.page * this.rowlimit);
			var lastpage = lastentry > this.total ? true : false;
			
			if (this.total == 0) {
				element.addClass('hidden');
			} else {
				element.removeClass('hidden');
				element.find('span.pagedisplay').text('Showing ' + ((this.page-1) * this.rowlimit + 1) + '-' + (lastpage ? this.total : lastentry) + '/' + this.total);
			}
			
			if (this.page == 1) {
				element.find('.first,.prev').addClass('disabled');
			} else {
				element.find('.first,.prev').removeClass('disabled');
			}
			
			if (lastpage) {
				element.find('.last,.next').addClass('disabled');
			} else {
				element.find('.last,.next').removeClass('disabled');
			}
		},
		connect: function() {
			var element = $(this.domElement);
			
			var that = this;
			element.next('.zdb-search-clear').click(function() {
				$(this).addClass('hidden');
				element.val('').focus();
				that.search('');
			});
			
			var that = this;
			element.keyup(function() {
				if ($(this).val() != '') {
					$(this).next('.zdb-search-clear').removeClass('hidden');
				} else {
					$(this).next('.zdb-search-clear').addClass('hidden');
				}
				clearTimeout(that.timer);
				that.timer = setTimeout(function() { that.search($(element).val()); }, 300);
			});
		},
		search: function(term) {
			this.term = term.trim();
			if (this.term == '') {
				this.storage.resetSearch();
			} else {
				this.storage.search(term);
			}
		}
	}
})(jQuery);

var $zendDevBar = $;